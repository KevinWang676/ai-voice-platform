{% extends "base.html" %}

{% block extra_css %}
<link href="https://cdnjs.cloudflare.com/ajax/libs/wavesurfer.js/7.7.3/wavesurfer.min.css    " rel="stylesheet">
<style>
body {
    background: linear-gradient(135deg, #FFE6E6, #FFE6EB) !important;
}

.tts-container {
    background: none;
    border-radius: 30px;
    padding: 3rem;
    margin-top: 6rem;
    box-shadow: none;
    will-change: transform;  /* Optimize animation performance */
    backface-visibility: hidden;  /* Prevent initial flicker */
}

.tts-title {
    font-size: 4.8rem;
    font-weight: 300;
    background: linear-gradient(120deg,
        #FF9A9E,
        #FAD0C4,
        #A1C4FD,
        #C2E9FB,
        #96E6A1
    );
    background-size: 300% 300%;
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-top: -20px;
    margin-bottom: 0.5rem;
    text-align: center;
    position: relative;
    letter-spacing: 0.1em;
    transform: translateZ(0);
    will-change: transform;
    animation: gradientFlow 15s ease infinite, gentleBreathing 4s ease-in-out infinite;
    transform-origin: center center;
}

/* Updated subtitle style - removed gradient, used color directly */
.tts-subtitle {
    text-align: center;
    font-size: 1.3rem; /* Adjusted size */
    margin: 1.5rem 0 2.5rem;
    font-weight: 600; /* Made slightly bolder */
    color: #E86A8D; /* Adjusted color */
    opacity: 0.9; /* Slightly less opaque */
}


@keyframes gradientFlow {
    0% {
        background-position: 0% 50%;
    }
    50% {
        background-position: 100% 50%;
    }
    100% {
        background-position: 0% 50%;
    }
}

@keyframes gentleBreathing {
    0%, 100% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.03);
    }
}

@media (min-width: 768px) {
    .tts-title {
        /* Keeping Chinese fonts for now as per instructions, but ideally change for English */
        font-family: "STKaiti", "KaiTi", "Kaiti SC", "Kaiti TC", "KaiTi_GB2312", "KaiTi_GB", "楷体", "华文楷体", serif;
    }
}

@media (max-width: 768px) {
    .tts-title {
        font-size: 3.2rem;
        margin-top: -15px;
        margin-bottom: 1rem;
        font-weight: 500;
    }

    .tts-subtitle {
        font-size: 1.1rem;
        padding: 0 1rem;
        margin: 1rem 0 2rem;
    }

    .tts-container {
        padding: 1.5rem;
        margin-top: 4rem;
    }

    @keyframes gentleBreathing {
        0%, 100% {
            transform: scale(1);
        }
        50% {
            transform: scale(1.02);
        }
    }
}

@media (min-width: 768px) and (max-width: 991px) {
    .tts-title {
        margin-top: -15px;
    }
}

/* Target the media query for smaller screens */
@media (max-width: 576px) {
    .tts-title {
        margin-top: -10px;
        font-size: 2.8rem;
    }
}

/* Remove any other background-related styles */
.model-card {
    background: rgba(255, 255, 255, 0.8);
    border-radius: 20px;
    padding: 1.5rem;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
    transition: all 0.3s ease;
    margin-bottom: 2rem;
    backdrop-filter: blur(10px);
    transform: translateZ(0);  /* Force GPU acceleration */
    will-change: transform;  /* Optimize animation performance */
}

.model-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.1);
}

.form-select {
    border: 2px solid rgba(78, 205, 196, 0.2);
    border-radius: 15px;
    padding: 1rem;
    font-size: 1rem;
    transition: all 0.3s ease;
}

.form-select:focus {
    border-color: var(--secondary-color);
    box-shadow: 0 0 0 0.25rem rgba(78, 205, 196, 0.25);
}

.text-input-card {
    background: white;
    border-radius: 20px;
    padding: 1.5rem;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.05);
    transform: translateZ(0);  /* Force GPU acceleration */
    will-change: transform;  /* Optimize animation performance */
}

.text-input-card textarea {
    border: 2px solid rgba(78, 205, 196, 0.2);
    border-radius: 15px;
    padding: 1rem;
    font-size: 1.1rem;
    min-height: 150px;
    transition: all 0.3s ease;
}

.text-input-card textarea:focus {
    border-color: var(--secondary-color);
    box-shadow: 0 0 0 0.25rem rgba(78, 205, 196, 0.25);
}

.char-counter {
    font-size: 0.9rem;
    color: #666;
    text-align: right;
    margin-top: 0.5rem;
    transition: all 0.3s ease;
}

.char-counter.near-limit {
    color: #f0ad4e;
}

.char-counter.at-limit {
    color: #dc3545;
}

.generate-btn {
    background: linear-gradient(-45deg, #FF6B6B, #4ECDC4, #FFD93D, #6C5CE7);
    background-size: 300% 300%;
    border: none;
    color: white;
    padding: 0.8rem 2rem;
    border-radius: 25px;
    font-weight: 600;
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    animation: gradientBG 10s ease infinite;
    width: auto;
    margin: 1rem auto;
    display: block;
    min-width: 200px;
}

.generate-btn::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    background: linear-gradient(-45deg, #FF6B6B, #4ECDC4, #FFD93D, #6C5CE7);
    background-size: 400% 400%;
    z-index: -1;
    animation: gradientBG 10s ease infinite;
    border-radius: 26px;
    filter: blur(5px);
    opacity: 0.7;
}

.generate-btn:hover {
    transform: translateY(-3px) scale(1.02);
    color: white;
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
}

.generate-btn:hover::before {
    filter: blur(8px);
    opacity: 0.8;
}

.generate-btn:active {
    transform: translateY(1px);
}

.generate-btn i {
    animation: floatFeather 3s ease-in-out infinite;
    display: inline-block;
}

.generate-btn:disabled {
    opacity: 0.7;
    transform: none;
    box-shadow: none;
    animation: none;
}

.generate-btn:disabled::before {
    display: none;
}

.audio-player-card {
    background: white;
    border-radius: 20px;
    padding: 1.5rem;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.05);
    margin-top: 2rem;
}

.waveform-container {
    background: rgba(78, 205, 196, 0.05);
    border-radius: 15px;
    padding: 1.5rem;
    margin-bottom: 1rem;
}

#waveform {
    border-radius: 10px;
    overflow: hidden;
}

.audio-controls {
    display: flex;
    gap: 1rem;
    margin-top: 1rem;
}

.audio-btn {
    flex: 1;
    padding: 0.8rem;
    border-radius: 15px;
    border: none;
    font-weight: 600;
    transition: all 0.3s ease;
}

.play-btn {
    background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
    color: white;
}

.download-btn {
    background: linear-gradient(45deg, #4ECDC4, #2ECC71);
    color: white;
}

.audio-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}

.loading-wave {
    width: 100%;
    height: 100px;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 8px;
}

.loading-bar {
    width: 8px;
    height: 40px;
    background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
    border-radius: 4px;
    animation: wave 1s ease-in-out infinite;
}

@keyframes wave {
    0%, 100% { transform: scaleY(0.5); }
    50% { transform: scaleY(1); }
}

.loading-bar:nth-child(2) { animation-delay: 0.1s; }
.loading-bar:nth-child(3) { animation-delay: 0.2s; }
.loading-bar:nth-child(4) { animation-delay: 0.3s; }
.loading-bar:nth-child(5) { animation-delay: 0.4s; }

/* Update chat-specific styles */
.chat-messages {
    background: var(--chat-bg);
    border-radius: 20px;
    padding: 1.5rem;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
}

.message {
    margin-bottom: 1.5rem;
    max-width: 85%;
    opacity: 0;
    transform: translateY(20px);
    animation: messageAppear 0.3s ease forwards;
}

@keyframes messageAppear {
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.message-user {
    margin-left: auto;
    background: linear-gradient(135deg, var(--primary-color), #FF8E8E);
    border-radius: 20px 20px 5px 20px;
    padding: 1.2rem 1.5rem;
    color: white;
    box-shadow: 0 3px 10px rgba(255, 107, 107, 0.2);
}

.message-ai {
    margin-right: auto;
    margin-left: 0;
    background: white;
    border-radius: 20px 20px 20px 5px;
    padding: 1.2rem 1.5rem;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.05);
    position: relative;
    width: fit-content;
    max-width: 85%;
}

.message-text {
    white-space: pre-wrap;
    word-break: break-word;
    line-height: 1.6;
    font-size: 1rem;
}

.message-text p {
    margin-bottom: 0.5rem;
}

.message-text p:last-child {
    margin-bottom: 0;
}

.message-text pre {
    background: rgba(0, 0, 0, 0.05);
    padding: 0.5rem;
    border-radius: 5px;
    overflow-x: auto;
}

.message-text code {
    background: rgba(0, 0, 0, 0.05);
    padding: 0.2rem 0.4rem;
    border-radius: 3px;
    font-size: 0.9em;
}

.message-text blockquote {
    border-left: 3px solid var(--primary-color);
    margin: 0.5rem 0;
    padding-left: 1rem;
    color: #666;
}

.message-text ul, .message-text ol {
    padding-left: 1.5rem;
    margin-bottom: 0.5rem;
}

.message-text img {
    max-width: 100%;
    height: auto;
    border-radius: 5px;
    margin: 0.5rem 0;
}

.message-ai .message-text {
    color: var(--text-color);
}

.chat-input-area {
    margin-top: 1.5rem;
    position: relative;
}

.chat-input-area .input-group {
    background: white;
    border-radius: 20px;
    padding: 0.7rem;
    box-shadow: 0 2px 15px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(0, 0, 0, 0.1);
}

.chat-input-area textarea {
    border: none;
    resize: none;
    box-shadow: none !important;
    font-size: 1rem;
    padding: 0.5rem 1rem;
    border-radius: 15px;
    background: transparent;
    min-height: 44px;
    max-height: 120px;
    overflow-y: auto;
}

.chat-input-area .btn {
    border-radius: 15px;
    padding: 0.8rem 1.2rem;
    background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
    border: none;
    color: white;
    font-weight: 600;
    transition: all 0.3s ease;
}

.chat-input-area .btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.chat-input-area .btn:disabled {
    opacity: 0.7;
    transform: none;
    box-shadow: none;
}

.chat-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 1rem;
    padding: 0 0.5rem;
}

.chat-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text-color);
    margin: 0;
}

.chat-actions {
    display: flex;
    gap: 0.5rem;
}

.btn-clear-chat {
    background: none;
    border: 1px solid rgba(0, 0, 0, 0.1);
    border-radius: 15px;
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
    color: var(--text-color);
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.btn-clear-chat:hover {
    background: rgba(0, 0, 0, 0.05);
    transform: translateY(-1px);
}

.btn-clear-chat i {
    font-size: 0.9rem;
}

/* Update chat-specific styles */
.modal-content {
    border: none;
    border-radius: 25px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
    background: linear-gradient(135deg, #ffffff, #f8f9fa);
}

.modal-header {
    padding: 1rem 1.5rem;
    display: flex;
    align-items: center;
    background: linear-gradient(135deg, #62d8c6, #7ae994);  /* Changed to green gradient */
    border-radius: 25px 25px 0 0;
    border-bottom: none;
}

.modal-header .left-section {
    display: flex;
    align-items: center;
    gap: 1rem;
    flex: 1;
}

.modal-title {
    margin: 0;
    font-size: 1.2rem !important;
    color: white;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

.modal-header .right-section {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.modal-header .btn-clear-chat {
    background: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: white;
    transition: all 0.3s ease;
}

.modal-header .btn-clear-chat:hover {
    background: rgba(255, 255, 255, 0.3);
    transform: translateY(-1px);
}

.btn-close {
    color: white;
    opacity: 0.8;
    filter: brightness(0) invert(1);
}

.btn-close:hover {
    opacity: 1;
}

.modal-footer {
    background: linear-gradient(135deg, #F8F9FA, #E9ECEF);
    border-radius: 0 0 25px 25px;
    border-top: none;
    padding: 1rem 1.5rem;
}

.modal-footer .btn-secondary {
    background: #6C757D;
    border: none;
    color: white;
}

.modal-footer .btn-secondary:hover {
    background: #5A6268;
}

.modal-footer .btn-primary {
    background: #4A90E2;
    color: white;
    border: none;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.modal-footer .btn-primary:hover {
    background: #357ABD;
    transform: translateY(-1px);
}

.chat-messages {
    height: 300px;
    margin-bottom: 1rem;
}

@media (min-width: 768px) {
    .chat-messages {
        height: 350px;
    }
}

.chat-input-area {
    margin-top: 1rem;
}

/* Add these styles to make the modal more compact and mobile-friendly */
.modal-dialog.modal-lg {
    max-width: 95%;
    margin: 1.75rem auto;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) !important;
    height: auto;
    max-height: 90vh;
    width: 95%;
}

@media (min-width: 992px) {
    .modal-dialog.modal-lg {
        max-width: 800px;
        width: 800px;
    }
}

.modal-content {
    max-height: 90vh;
    overflow-y: auto;
    margin: 0 auto;
    position: relative;
    width: 100%;
}

.modal-body {
    overflow-y: auto;
}

.chat-messages {
    max-height: calc(90vh - 200px);
    overflow-y: auto;
}

#doubaoLoading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: transparent;
    border-radius: 20px;
    padding: 2rem;
    text-align: center;
    z-index: 1000;
}

.loading-wave {
    margin-bottom: 1rem;
    background: transparent;
}

#doubaoLoading p {
    color: rgba(44, 62, 80, 0.7);  /* Using var(--text-color) with opacity */
    font-size: 0.95rem;
    margin-top: 1rem;
    text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
}

/* Add these responsive styles to the existing CSS */
@media (max-width: 768px) {
    .tts-container {
        padding: 1.5rem;
        margin-top: 4rem;
    }

    .tts-title {
        font-size: 3rem;
        margin-bottom: 1.5rem;
        margin-top: -15px;
        z-index: 2;
    }

    .tts-title::before {
        width: 240px;
        height: 140px;
        top: -40px;
    }

    .model-card, .text-input-card {
        padding: 1rem;
    }

    .form-select {
        padding: 0.8rem;
        font-size: 1rem;
    }

    .text-input-card textarea {
        padding: 0.8rem;
        font-size: 1rem;
        min-height: 120px;
    }

    .generate-btn {
        width: 100%;
        padding: 0.7rem 1.5rem;
        font-size: 1rem;
    }

    .audio-player-card {
        padding: 1rem;
    }

    .waveform-container {
        padding: 1rem;
    }

    .audio-controls {
        flex-direction: column;
        gap: 0.5rem;
    }

    .audio-btn {
        width: 100%;
        padding: 0.7rem;
    }

    /* Modal adjustments for mobile */
    .modal-dialog.modal-lg {
        margin: 0.5rem;
        max-width: calc(100% - 1rem);
    }

    .modal-header {
        padding: 0.8rem 1rem;
    }

    .modal-body {
        padding: 1rem;
    }

    .modal-footer {
        padding: 0.8rem 1rem;
    }

    .chat-messages {
        height: calc(100vh - 300px);
        max-height: 400px;
    }

    /* Adjust the header layout for mobile */
    .d-flex.justify-content-between.align-items-center.mb-3 {
        flex-direction: column;
        gap: 0.5rem;
        align-items: flex-start !important;
    }

    .form-label.h5 {
        font-size: 1.1rem;
        margin-bottom: 0.5rem;
    }

    #doubaoBtn {
        width: 100%;
        margin-bottom: 0.5rem;
    }

    /* Adjust the character counter and info text for mobile */
    .d-flex.justify-content-between.align-items-center.mt-2 {
        flex-direction: column;
        align-items: flex-start !important;
        gap: 0.5rem;
    }

    .text-muted {
        font-size: 0.85rem;
    }

    .char-counter {
        align-self: flex-end;
        margin-top: 0.25rem;
    }

    /* Modal header adjustments */
    .modal-header .left-section {
        flex: 1;
    }

    .modal-header .right-section {
        flex-wrap: nowrap;
    }

    .btn-clear-chat {
        padding: 0.3rem 0.8rem;
        font-size: 0.85rem;
    }

    /* Chat input area adjustments */
    .chat-input-area .input-group {
        padding: 0.5rem;
    }

    .chat-input-area textarea {
        font-size: 0.95rem;
    }

    .chat-input-area .btn {
        padding: 0.6rem 1rem;
    }

    /* Loading animation adjustments */
    .loading-wave {
        height: 80px;
    }

    .loading-bar {
        width: 6px;
        height: 30px;
    }

    #doubaoLoading {
        padding: 1.5rem;
    }

    #doubaoLoading p {
        font-size: 0.9rem;
    }
}

/* Add styles for better touch interaction */
@media (hover: none) {
    .btn:active, .audio-btn:active, .generate-btn:active {
        transform: scale(0.98);
    }
}

.fancy-poetry-hello {
        background: linear-gradient(120deg, #4568dc, #b06ab3);
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-size: 1.2rem;
        letter-spacing: 2px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        animation: fadeIn 1s ease-in-out;
}

.writing-text.fancy-poetry-hello {
    font-size: inherit;
    display: inline-block;
    vertical-align: baseline;
    margin: 0 4px;
}

/* Removed Chinese font check */

/* Adjust modal for iPhone notch */
@supports (padding-top: env(safe-area-inset-top)) {
    .modal-dialog {
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
    }
}

/* Add smooth scrolling for iOS */
.chat-messages {
    -webkit-overflow-scrolling: touch;
}

.creative-ai-btn {
    background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
    border: none;
    border-radius: 25px;
    padding: 0.8rem 1.5rem;
    font-weight: 600;
    color: white;
    transition: all 0.3s ease;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
}

.creative-ai-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.creative-ai-btn:active {
    transform: translateY(1px);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

.creative-ai-btn i {
    display: inline-block;
}

.custom-voice-upload {
    background: rgba(255, 255, 255, 0.5);
    border-radius: 15px;
    padding: 1.5rem;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
    backdrop-filter: blur(10px);
}

.custom-voice-upload:hover {
    background: rgba(255, 255, 255, 0.7);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
    transform: translateY(-2px);
}

.custom-voice-upload .form-control {
    border: 2px solid rgba(78, 205, 196, 0.2);
    border-radius: 30px;
    padding: 1rem 1.2rem;
    transition: all 0.3s ease;
    background: rgba(255, 255, 255, 0.9);
    font-size: 0.95rem;
}

.custom-voice-upload .form-control:hover {
    border-color: rgba(78, 205, 196, 0.4);
    background: white;
}

.custom-voice-upload .form-control:focus {
    border-color: var(--secondary-color);
    box-shadow: 0 0 0 0.25rem rgba(78, 205, 196, 0.25);
    background: white;
}

.custom-voice-upload input[type="file"] {
    position: relative;
    padding-left: 8.5rem;  /* Increased padding to make room for the button */
    color: transparent;  /* Hide the default text */
}

.custom-voice-upload input[type="file"]::-webkit-file-upload-button {
    visibility: hidden;
    display: none;
}

.custom-voice-upload input[type="file"]::before {
    content: "No file selected";
    position: absolute;
    left: 8.5rem;
    top: 50%;
    transform: translateY(-50%);
    color: #6c757d;
    pointer-events: none;
    font-size: 0.9rem;
}

.custom-voice-upload input[type="file"]::after {
    content: 'Upload';
    position: absolute;
    left: 1rem;
    top: 50%;
    transform: translateY(-50%);
    background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
    color: white;
    padding: 0.4rem 1rem;
    border-radius: 20px;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.3s ease;
}

.custom-voice-upload input[type="file"]:hover::after {
    transform: translateY(-50%) scale(1.05);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

.custom-voice-upload .form-text {
    color: #666;
    font-size: 0.9rem;
    margin-top: 0.8rem;
    padding-left: 1rem;
}

.custom-voice-upload label {
    font-weight: 500;
    color: #2C3E50;
    margin-bottom: 0.8rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.custom-voice-upload label small {
    font-weight: normal;
    opacity: 0.7;
}

.preview-section {
    background: rgba(78, 205, 196, 0.05);
    border-radius: 12px;
    padding: 1.2rem;
    transition: all 0.3s ease;
    margin-top: 1rem;
    box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.05);
}

.preview-section audio {
    border-radius: 8px;
    background: white;
    width: 100%;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
}

@media (max-width: 768px) {
    .custom-voice-upload {
        padding: 1rem;
    }

    .custom-voice-upload input[type="file"] {
        font-size: 0.9rem;
        padding-left: 3rem;
    }

    .custom-voice-upload input[type="file"]::after {
        padding: 0.3rem 0.8rem;
        font-size: 0.8rem;
    }
}

/* Add animation for section transitions */
#presetVoiceSection,
#customVoiceSection {
    transition: all 0.3s ease;
    opacity: 1;
}

#presetVoiceSection.hiding,
#customVoiceSection.hiding {
    opacity: 0;
    transform: translateY(10px);
}

#presetVoiceSection.showing,
#customVoiceSection.showing {
    opacity: 1;
    transform: translateY(0);
}

/* Style for the custom voice only elements */
.custom-voice-only {
    transition: all 0.3s ease;
    opacity: 1;
}

.custom-voice-only.hiding {
    opacity: 0;
    height: 0;
    overflow: hidden;
    margin: 0;
    padding: 0;
}

/* Make sure elements are hidden when needed */
#presetVoice:checked ~ * .custom-voice-only,
#longTextVoice:checked ~ * .custom-voice-only {
    display: none !important;
}

/* Add custom styling for model select */
#modelSelect {
    appearance: none;
    background: linear-gradient(135deg, #ffffff, #f8f9fa);
    border: none;
    border-radius: 20px;
    padding: 1.2rem;
    font-size: 1.1rem;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
    transition: all 0.3s ease;
    cursor: pointer;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg    ' viewBox='0 0 24 24' fill='%234ECDC4'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 1rem center;
    background-size: 2rem;
}

#modelSelect:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
}

#modelSelect:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(78, 205, 196, 0.25), 0 8px 25px rgba(0, 0, 0, 0.1);
}

#modelSelect option {
    padding: 1rem;
    background: white;
    color: #2C3E50;
    font-size: 1.1rem;
    border-radius: 10px;
}

/* Add custom styling for each option */
#modelSelect option[value="QiYu"] {
    background: linear-gradient(135deg, #E8F6F3, #D1F2EB);
}

#modelSelect option[value="XingHui"] {
    background: linear-gradient(135deg, #EBF5FB, #D4E6F1);
}

#modelSelect option[value="LiShen"] {
    background: linear-gradient(135deg, #EAFAF1, #D4EFDF);
}

#modelSelect option[value="BadXingTong"] {
    background: linear-gradient(135deg, #FDF2E9, #FAE5D3);
}

#modelSelect option[value="Diana"] {
    background: linear-gradient(135deg, #F4ECF7, #E8DAEF);
}

/* Add icons and better formatting for options */
#modelSelect option::before {
    content: '';
    display: inline-block;
    width: 20px;
    height: 20px;
    margin-right: 10px;
    vertical-align: middle;
}

/* Custom select wrapper for better control */
.select-wrapper {
    position: relative;
    margin-top: 1rem;
}

.select-wrapper::after {
    display: none;  /* Hide the duplicate arrow */
}

/* Add animation for option hover */
@keyframes optionHover {
    0% {
        transform: translateX(0);
    }
    50% {
        transform: translateX(5px);
    }
    100% {
        transform: translateX(0);
    }
}

#modelSelect option:hover {
    animation: optionHover 0.3s ease;
}

/* Add responsive styles */
@media (max-width: 768px) {
    #modelSelect {
        font-size: 1rem;
        padding: 1rem;
    }

    #modelSelect option {
        font-size: 1rem;
        padding: 0.8rem;
    }
}

/* Add these styles for better mobile compatibility */
.voice-source-selection {
    margin-bottom: 1.5rem;
}

.voice-source-selection .form-label {
    margin-bottom: 0;
}

.voice-source-buttons {
    display: flex;
    gap: 0.5rem;
}

@media (min-width: 768px) {
    .voice-source-selection {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
}

@media (max-width: 767px) {
    .voice-source-selection {
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }

    .voice-source-buttons {
        width: 100%;
    }

    .voice-source-buttons .btn {
        flex: 1;
    }
}

/* Reverted tts-subtitle style to original */
.tts-subtitle {
    text-align: center;
    font-size: 1.3rem;
    margin: 1.5rem 0 2.5rem;
    font-weight: bold;
    background: linear-gradient(120deg, #e5531a, #fc750d);
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    opacity: 0.95;
}


@media (max-width: 768px) {
    .tts-subtitle {
        font-size: 1.1rem; /* Keep mobile size consistent */
        padding: 0 1rem;
    }
}

@keyframes gradientBG {
    0% {
        background-position: 0% 50%;
    }
    50% {
        background-position: 100% 50%;
    }
    100% {
        background-position: 0% 50%;
    }
}

@keyframes floatFeather {
    0%, 100% {
        transform: rotate(0deg) translateY(0);
    }
    25% {
        transform: rotate(5deg) translateY(-3px);
    }
    75% {
        transform: rotate(-5deg) translateY(3px);
    }
}

/* Add new styles for the useLatestResponseBtn */
#useLatestResponseBtn {
    background: linear-gradient(-45deg, #28a745, #34d058, #85e89d, #40916c);
    background-size: 300% 300%;
    border: none;
    color: white !important;
    padding: 0.8rem 1.5rem;
    border-radius: 25px;
    font-weight: 600;
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
    box-shadow: 0 4px 15px rgba(40, 167, 69, 0.2);
    animation: gradientBG 10s ease infinite;
}

#useLatestResponseBtn::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    background: linear-gradient(-45deg, #28a745, #34d058, #85e89d, #40916c);
    background-size: 400% 400%;
    z-index: -1;
    animation: gradientBG 10s ease infinite;
    border-radius: 26px;
    filter: blur(5px);
    opacity: 0.7;
}

#useLatestResponseBtn:hover {
    transform: translateY(-3px) scale(1.02);
    color: white;
    box-shadow: 0 6px 20px rgba(40, 167, 69, 0.25);
}

#useLatestResponseBtn:hover::before {
    filter: blur(8px);
    opacity: 0.8;
}

#useLatestResponseBtn:active {
    transform: translateY(1px);
}

#useLatestResponseBtn i {
    animation: checkmark 3s ease-in-out infinite;
    display: inline-block;
    color: white;
}

@keyframes checkmark {
    0%, 100% {
        transform: scale(1) rotate(0deg);
    }
    25% {
        transform: scale(1.1) rotate(-10deg);
    }
    75% {
        transform: scale(1.1) rotate(10deg);
    }
}

.pulse-dot {
    width: 8px;
    height: 8px;
    background: white;
    border-radius: 50%;
    box-shadow: 0 0 0 rgba(255, 255, 255, 0.4);
    animation: pulseDot 1.5s ease-in-out infinite;
}

@keyframes pulseDot {
    0% {
        transform: translate(-50%, -50%) scale(1);
        box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4);
    }
    70% {
        transform: translate(-50%, -50%) scale(1.2);
        box-shadow: 0 0 0 10px rgba(255, 255, 255, 0);
    }
    100% {
        transform: translate(-50%, -50%) scale(1);
        box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);
    }
}

.btn-check:checked + .btn-outline-primary {
    background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
    border-color: transparent;
    color: white;
}

.btn-check + .btn-outline-primary {
    border: 2px solid var(--primary-color);
    color: var(--primary-color);
    transition: all 0.3s ease;
    border-radius: 30px;
    padding: 8px 20px;
    background: transparent;
}

.btn-check:checked + .btn-outline-primary {
    background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
    color: #fff;
    border: none;
    padding: 10px 22px;  /* Compensate for border removal */
}

.btn-check + .btn-outline-primary:hover {
    background: rgba(var(--primary-rgb), 0.1);
    border-color: var(--primary-color);
    color: var(--primary-color);
}

/* Additional styles may be present */

/* Text examples dropdown styling */
.text-examples-dropdown {
    width: 350px;
    max-width: 100%;
    max-height: 400px;
    overflow-y: auto;
    padding: 0.5rem;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    border-radius: 12px;
    border: 1px solid rgba(78, 205, 196, 0.2);
}

.text-examples-dropdown .dropdown-header {
    color: #4ECDC4;
    font-weight: bold;
    padding: 0.5rem 1rem;
    border-bottom: 1px solid rgba(78, 205, 196, 0.2);
    margin-bottom: 0.5rem;
}

.text-examples-dropdown .dropdown-item {
    border-radius: 8px;
    margin-bottom: 0.25rem;
    padding: 0.75rem 1rem;
    white-space: normal;
    line-height: 1.5;
    font-size: 0.95rem;
    transition: all 0.2s ease;
}

.text-examples-dropdown .dropdown-item:hover {
    background-color: rgba(78, 205, 196, 0.1);
    transform: translateY(-2px);
}

.text-examples-dropdown .dropdown-item:active {
    background-color: rgba(78, 205, 196, 0.2);
}

.loading-wait, .audio-spinner, .loading-dot {
    background-color: rgba(78, 205, 196, 0.8);
}
/* Emotion selector styling */
.emotion-selector {
    border: 2px solid rgba(78, 205, 196, 0.2);
    border-radius: 15px;
    padding: 0.4rem 0.8rem;
    transition: all 0.3s ease;
    background: white;
    width: 140px;
    font-size: 0.85rem;
}

.emotion-selector:focus {
    border-color: var(--secondary-color);
    box-shadow: 0 0 0 0.2rem rgba(78, 205, 196, 0.25);
    outline: none;
}

/* Responsive adjustments for smaller screens */
@media (max-width: 768px) {
    .emotion-selector {
        width: 120px;
        padding: 0.3rem 0.5rem;
        font-size: 0.8rem;
    }

    #emotionSelectContainer {
        margin-top: 0.5rem;
        margin-left: 2.5rem !important;
    }

    .voice-source-selection .d-flex.align-items-center {
        flex-wrap: wrap;
    }
}

@media (max-width: 576px) {
    .voice-source-selection .d-flex.align-items-center {
        flex-direction: column;
        align-items: flex-start !important;
    }

    #emotionSelectContainer {
        margin-left: 0 !important;
        margin-top: 0.5rem;
        width: 100%;
    }

    .emotion-selector {
        width: 150px;
    }
}

/* Speed slider custom styling */
.custom-range {
    height: 8px;
    background: linear-gradient(90deg, #d1e7ff 0%, #7A36B1 100%);
    border-radius: 10px;
}

.custom-range::-webkit-slider-thumb {
    width: 20px;
    height: 20px;
    background: #7A36B1;
    border: 2px solid #fff;
    border-radius: 50%;
    cursor: pointer;
    -webkit-appearance: none;
    box-shadow: 0 0 8px rgba(123, 54, 177, 0.3);
    transition: all 0.2s ease;
}

.custom-range::-webkit-slider-thumb:hover {
    background: #4568DC;
    transform: scale(1.1);
}

.custom-range::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: #7A36B1;
    border: 2px solid #fff;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 8px rgba(123, 54, 177, 0.3);
    transition: all 0.2s ease;
}

.custom-range::-moz-range-thumb:hover {
    background: #4568DC;
    transform: scale(1.1);
}

/* Add these styles for the custom model settings */
.advanced-options-section {
    margin-top: 1rem;
    border-radius: 15px;
    padding: 1.2rem;
    background: rgba(255, 255, 255, 0.6);
    border: 1px solid rgba(78, 205, 196, 0.2);
}

.custom-model-inputs {
    margin-top: 1rem;
    transition: all 0.3s ease;
}

.custom-model-inputs.hiding {
    display: none;
    height: 0;
    opacity: 0;
    overflow: hidden;
}

/* Custom style to make speaker select boxes smaller */
.speaker-voice-select.form-select-sm {
    padding-top: 0.2rem; /* Reduced padding */
    padding-bottom: 0.2rem; /* Reduced padding */
    height: auto; /* Let height adjust to padding and font-size */
    font-size: 1rem; /* Keep standard sm font size */
}

/* Enhanced styles for save voice buttons */
#saveVoiceBtn, #longTextSaveVoiceBtn {
    position: relative;
    overflow: hidden;
    background: linear-gradient(-45deg, #9aee47, #4ECDC4);
    color: white;
    border: none;
    font-weight: 600;
    padding: 0.5rem 1rem;
    border-radius: 20px;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
    animation: saveButtonGlow 2s infinite alternate;
}

#saveVoiceBtn:hover, #longTextSaveVoiceBtn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
    background: linear-gradient(-45deg, #4ECDC4, #9aee47);
}

#saveVoiceBtn:active, #longTextSaveVoiceBtn:active {
    transform: translateY(1px);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

#saveVoiceBtn i, #longTextSaveVoiceBtn i {
    margin-right: 6px;
    animation: saveIconPulse 1.5s ease-in-out infinite;
}

@keyframes saveButtonGlow {
    0% {
        box-shadow: 0 4px 10px rgba(72, 235, 118, 0.3);
    }
    100% {
        box-shadow: 0 4px 20px rgba(239, 239, 138, 0.5);
    }
}

@keyframes saveIconPulse {
    0% {
        transform: scale(1);
        opacity: 0.9;
    }
    50% {
        transform: scale(1.2);
        opacity: 1;
    }
    100% {
        transform: scale(1);
        opacity: 0.9;
    }
}

.custom-voice-upload input[type="file"].has-file::before {
    content: attr(data-filename);
}
</style>
{% endblock %}

{% block content %}
<div class="container">
    <div class="tts-container">
        <h1 class="tts-title">DreamSpeech</h1>
        <h2 class="tts-subtitle">CosyVoice 2.0 + F5 TTS: Realistic emotion & voice cloning. Up to 1000 characters.</h2>

        <form id="ttsForm">
            <!-- Error alert container -->
            <div id="errorAlert" class="alert alert-danger mb-4" style="display: none;">
                <i class="fas fa-exclamation-circle me-2"></i>
                <span id="errorMessage">An error occurred. Please try again later.</span>
            </div>

            <div class="model-card">
                <div class="voice-source-selection">
                    <div class="d-flex justify-content-between align-items-center">
                        <div class="d-flex align-items-center">
                            <label class="form-label h5 mb-0">Select DreamSpeech Source</label>
                        </div>
                        {% if not current_user.is_authenticated %}
                        <div class="login-notification" style="margin-left: 20px;">
                            <small class="text-muted"><a href="/login" class="text-primary fw-bold">Login</a> to enable DreamSpeech</small>
                        </div>
                        {% endif %}
                    </div>
                    <div class="voice-source-buttons">
                        <input type="radio" class="btn-check" name="voiceSource" id="customVoice" checked>
                        <label class="btn btn-outline-primary" for="customVoice">
                            <i class="fas fa-microphone me-1"></i>Default Model
                        </label>

                        <input type="radio" class="btn-check" name="voiceSource" id="longTextVoice">
                        <label class="btn btn-outline-primary" for="longTextVoice">
                            <i class="fas fa-file-alt me-1"></i>Long Text Mode
                        </label>

                        <input type="radio" class="btn-check" name="voiceSource" id="multiSpeakerVoice">
                        <label class="btn btn-outline-primary" for="multiSpeakerVoice">
                            <i class="fas fa-users me-1"></i>Multi-Speaker
                        </label>
                    </div>
                </div>

                <div id="customVoiceSection">
                    <div class="custom-voice-upload">
                        <div class="mb-3">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label for="audioFile" class="form-label mb-0">Upload clear speech as a voice reference <small class="text-muted">(WAV/MP3, 3-15 seconds)</small></label>
                                {% if current_user.is_authenticated %}
                                <div class="d-flex align-items-center">
                                    <div class="form-check form-switch mb-0">
                                        <input type="checkbox" class="form-check-input" id="useAzureTTS" style="width: 2.5em; height: 1.25em;">
                                        <label class="form-check-label" for="useAzureTTS" style="margin-left: 0.5em;">
                                            <i class="fas fa-rocket me-1 text-danger"></i><span class="fw-bold text-danger">Enable Multilingual Model</span>
                                        </label>
                                    </div>
                                    <div id="emotionSelectContainer" style="display: none !important;" class="ms-3 d-flex align-items-center flex-wrap" hidden>
                                        <small class="text-muted me-2">Emotion Control:</small>
                                        <select id="emotion-select" class="form-select form-select-sm emotion-selector">
                                            <option value="default" selected>Default</option>
                                            <option value="affectionate">Affectionate</option>
                                            <option value="cheerful">Cheerful</option>
                                            <option value="empathetic">Empathetic</option>
                                            <option value="excited">Excited</option>
                                            <option value="sorry">Sorry</option>
                                        </select>
                                    </div>
                                </div>
                                {% endif %}
                            </div>
                            <input type="file" class="form-control" id="audioFile" accept=".wav,.mp3,.m4a,.flac" required> <!-- Allow MP3 too -->
                        </div>

                        <div class="mb-3">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label for="audioTranscription" class="form-label mb-0">Enter the corresponding text for the audio, or enable voice control</label>
                                <div class="form-check form-switch mb-0">
                                    <input type="checkbox" class="form-check-input" id="useInstructMode" style="width: 2.5em; height: 1.25em;">
                                    <label class="form-check-label" for="useInstructMode" style="margin-left: 0.5em;">
                                        <i class="fas fa-magic me-1"></i>Enable Voice Control
                                    </label>
                                </div>
                            </div>
                            <textarea class="form-control" id="audioTranscription" rows="2"
                                     placeholder="Enter the text corresponding to the uploaded audio..." required></textarea>
                        </div>

                        <!-- Add speed control slider -->
                        <div class="mb-3">
                            <label for="speedSlider" class="form-label d-flex justify-content-between mb-2">
                                <span>Adjust Speed <small class="text-muted">(0.5 = Slow, 1.0 = Normal, 2.0 = Fast)</small></span>
                                <span id="speedValue">1.00</span>
                            </label>
                            <input type="range" class="form-range custom-range" id="speedSlider"
                                  min="0.5" max="2.0" step="0.01" value="1.0">
                        </div>

                        <!-- Remove the natural language control option since we moved it above -->

                        <div class="preview-section mb-3" style="display: none;">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label class="form-label mb-0">Audio Preview</label>
                                <button type="button" id="saveVoiceBtn" data-bs-toggle="tooltip" title="Save this voice for future use" style="display: none;">
                                    <i class="fas fa-save"></i>Save This Voice
                                </button>
                            </div>
                            <audio id="audioPreview" controls class="w-100">
                                <source src="" type="audio/wav">
                                Your browser does not support audio preview.
                            </audio>
                        </div>

                        <div class="mb-3" id="savedVoicesSection">
                            <div class="d-flex align-items-center mb-1">
                                <label for="savedVoicesSelect" class="form-label mb-0 me-auto" style="font-size: 0.95rem;">
                                    <i class="fas fa-history me-1"></i>Saved Voices <span class="badge bg-secondary">(0/5)</span>
                                </label>
                                <div class="btn-group btn-group-sm ms-2">
                                    <button type="button" id="refreshVoicesBtn" class="btn btn-outline-secondary" title="Refresh saved voices">
                                        <i class="fas fa-sync-alt"></i>
                                    </button>
                                    <button type="button" id="manageVoicesBtn" class="btn btn-outline-secondary" title="Manage voices">
                                        <i class="fas fa-cog"></i>
                                    </button>
                                </div>
                            </div>
                            <select class="form-select form-select-sm" id="savedVoicesSelect">
                                <option value="" selected>-- Select a saved voice (auto-fills) --</option>
                                <!-- Options will be populated by JavaScript -->
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Add new section for long text mode -->
                <div id="longTextSection" style="display: none;">
                    <div class="custom-voice-upload">
                        <div class="mb-3">
                            <label for="longTextAudioFile" class="form-label">Upload clear audio as a voice reference<small class="text-muted">(WAV/MP3, 3-15 seconds)</small></label>
                            <input type="file" class="form-control" id="longTextAudioFile" accept=".wav,.mp3,.m4a,.flac" required>
                        </div>

                        <div class="mb-3">
                            <label for="longTextTranscription" class="form-label mb-0">Enter the corresponding text for the audio</label>
                            <textarea class="form-control" id="longTextTranscription" rows="2"
                                     placeholder="Enter the text corresponding to the uploaded audio..." required></textarea>
                        </div>

                        <!-- Share speed control slider with custom voice section -->
                        <div class="mb-3">
                            <label for="longTextSpeedSlider" class="form-label d-flex justify-content-between mb-2">
                                <span>Adjust Speed <small class="text-muted">(0.5 = Slow, 1.0 = Normal, 2.0 = Fast)</small></span>
                                <span id="longTextSpeedValue">1.00</span>
                            </label>
                            <input type="range" class="form-range custom-range" id="longTextSpeedSlider"
                                  min="0.5" max="2.0" step="0.01" value="1.0">
                        </div>

                        <div class="preview-section mb-3" style="display: none;">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label class="form-label mb-0">Audio Preview</label>
                                <button type="button" id="longTextSaveVoiceBtn" data-bs-toggle="tooltip" title="Save this voice for future use" style="display: none;">
                                    <i class="fas fa-save"></i>Save This Voice
                                </button>
                            </div>
                            <audio id="longTextAudioPreview" controls class="w-100">
                                <source src="" type="audio/wav">
                                Your browser does not support audio preview.
                            </audio>
                        </div>

                        <!-- Add saved voices section for long text tab -->
                        <div class="mb-3" id="longTextSavedVoicesSection">
                            <div class="d-flex align-items-center mb-1">
                                <label for="longTextSavedVoicesSelect" class="form-label mb-0 me-auto" style="font-size: 0.95rem;">
                                    <i class="fas fa-history me-1"></i>Saved Voices <span class="badge bg-secondary">(0/5)</span>
                                </label>
                                <div class="btn-group btn-group-sm ms-2">
                                    <button type="button" id="longTextRefreshVoicesBtn" class="btn btn-outline-secondary" title="Refresh saved voices">
                                        <i class="fas fa-sync-alt"></i>
                                    </button>
                                    <button type="button" id="longTextManageVoicesBtn" class="btn btn-outline-secondary" title="Manage voices">
                                        <i class="fas fa-cog"></i>
                                    </button>
                                </div>
                            </div>
                            <select class="form-select form-select-sm" id="longTextSavedVoicesSelect">
                                <option value="" selected>-- Select a saved voice (auto-fills) --</option>
                                <!-- Options will be populated by JavaScript -->
                            </select>
                        </div>
                    </div>
                </div>

                <!-- After the longTextSection, add the new multiSpeakerSection -->
                <div id="multiSpeakerSection" style="display: none;">
                    <div class="custom-voice-upload">
                        <!-- Add a refresh button in the multi-speaker section above the first speaker -->
                        <div class="alert text-muted mb-3 d-flex justify-content-between align-items-center">
                            <div>
                                <i class="fas fa-lightbulb me-1"></i>Enable multi-speaker dialogue, using a different saved voice for each text segment. Voices are saved from the 'Default Model' tab. <span id="multiSpeakerLimitsText">Free users support 2 speakers / 200 characters. Members support 6 speakers / 1000 characters.</span>
                            </div>
                            <button type="button" id="refreshMultiSpeakerVoicesBtn" class="btn btn-sm btn-outline-secondary ms-3">
                                <i class="fas fa-sync-alt me-1"></i>Refresh Voice List
                            </button>
                        </div>

                        <!-- Speaker 1 -->
                        <div class="mb-4 speaker-section">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label class="form-label mb-0"><i class="fas fa-user-circle me-1"></i>Speaker 1</label>
                                <select class="form-select form-select-sm speaker-voice-select" style="width: auto; min-width: 200px;">
                                    <option value="" selected>-- Select Voice --</option>
                                    <!-- Options will be populated by JavaScript -->
                                </select>
                            </div>
                            <textarea class="form-control speaker-text" rows="3"
                                placeholder="Enter text for speaker 1..."></textarea>
                        </div>

                        <!-- Speaker 2 -->
                        <div class="mb-4 speaker-section">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label class="form-label mb-0"><i class="fas fa-user-circle me-1"></i>Speaker 2</label>
                                <select class="form-select form-select-sm speaker-voice-select" style="width: auto; min-width: 200px;">
                                    <option value="" selected>-- Select Voice --</option>
                                    <!-- Options will be populated by JavaScript -->
                                </select>
                            </div>
                            <textarea class="form-control speaker-text" rows="3"
                                placeholder="Enter text for speaker 2..."></textarea>
                        </div>

                        <!-- Add Speaker Button -->
                        <div class="text-center mb-4" id="addSpeakerBtnContainer">
                            <button type="button" id="addSpeakerBtn" class="btn btn-sm btn-outline-primary">
                                <i class="fas fa-plus-circle me-1"></i>Add New Speaker
                            </button>
                        </div>

                        <!-- Speaker 3 (hidden by default) -->
                        <div class="mb-4 speaker-section" id="speaker-section-3" style="display: none;">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label class="form-label mb-0"><i class="fas fa-user-circle me-1"></i>Speaker 3</label>
                                <select class="form-select form-select-sm speaker-voice-select" style="width: auto; min-width: 200px;">
                                    <option value="" selected>-- Select Voice --</option>
                                    <!-- Options will be populated by JavaScript -->
                                </select>
                            </div>
                            <textarea class="form-control speaker-text" rows="3"
                                placeholder="Enter text for speaker 3..."></textarea>
                        </div>

                        <!-- Speaker 4 (hidden by default) -->
                        <div class="mb-4 speaker-section" id="speaker-section-4" style="display: none;">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label class="form-label mb-0"><i class="fas fa-user-circle me-1"></i>Speaker 4</label>
                                <select class="form-select form-select-sm speaker-voice-select" style="width: auto; min-width: 200px;">
                                    <option value="" selected>-- Select Voice --</option>
                                    <!-- Options will be populated by JavaScript -->
                                </select>
                            </div>
                            <textarea class="form-control speaker-text" rows="3"
                                placeholder="Enter text for speaker 4..."></textarea>
                        </div>

                        <!-- Speaker 5 (hidden by default) -->
                        <div class="mb-4 speaker-section" id="speaker-section-5" style="display: none;">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label class="form-label mb-0"><i class="fas fa-user-circle me-1"></i>Speaker 5</label>
                                <select class="form-select form-select-sm speaker-voice-select" style="width: auto; min-width: 200px;">
                                    <option value="" selected>-- Select Voice --</option>
                                    <!-- Options will be populated by JavaScript -->
                                </select>
                            </div>
                            <textarea class="form-control speaker-text" rows="3"
                                placeholder="Enter text for speaker 5..."></textarea>
                        </div>

                        <!-- Speaker 6 (hidden by default) -->
                        <div class="mb-4 speaker-section" id="speaker-section-6" style="display: none;">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <label class="form-label mb-0"><i class="fas fa-user-circle me-1"></i>Speaker 6</label>
                                <select class="form-select form-select-sm speaker-voice-select" style="width: auto; min-width: 200px;">
                                    <option value="" selected>-- Select Voice --</option>
                                    <!-- Options will be populated by JavaScript -->
                                </select>
                            </div>
                            <textarea class="form-control speaker-text" rows="3"
                                placeholder="Enter text for speaker 6..."></textarea>
                        </div>

                        <!-- Speed control for multi-speaker -->
                        <div class="mb-3">
                            <label for="multiSpeakerSpeedSlider" class="form-label d-flex justify-content-between mb-2">
                                <span>Adjust Speed <small class="text-muted">(0.5 = Slow, 1.0 = Normal, 2.0 = Fast)</small></span>
                                <span id="multiSpeakerSpeedValue">1.00</span>
                            </label>
                            <input type="range" class="form-range custom-range" id="multiSpeakerSpeedSlider"
                                  min="0.5" max="2.0" step="0.01" value="1.0">
                        </div>


                        <!-- Add generate button for multi-speaker mode with improved styles -->
                        <button type="button" class="generate-btn w-100 mt-3" id="multiSpeakerGenerateBtn" style="margin: 1.5rem auto;">
                            <i class="fas fa-magic me-2"></i>Generate Multi-Speaker Audio
                        </button>
                    </div>
                </div>
            </div>

            <div class="text-input-card">
                <div class="input-section">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <div>
                            <label for="inputText" class="form-label h5 mb-0">Enter the text you want to convert to speech</label>
                            <div class="text-danger small mt-1"><i class="fas fa-exclamation-triangle me-1"></i>Prohibited: Using this platform for illegal or inappropriate content. Users are responsible for generated content; the platform assumes no liability.</div>
                        </div>
                        <button type="button" class="creative-ai-btn custom-voice-only" id="doubaoBtn"
                                {% if current_user.is_authenticated %}
                                data-bs-toggle="dropdown" aria-expanded="false"
                                {% endif %}
                                data-is-authenticated="{{ current_user.is_authenticated|tojson|safe }}">
                            <i class="fas fa-lightbulb me-2"></i> Get Text Examples
                        </button>
                        <ul class="dropdown-menu text-examples-dropdown" aria-labelledby="doubaoBtn">
                            <li><h6 class="dropdown-header">Click to use an example text</h6></li>
                            <li><a class="dropdown-item text-example" href="#">Welcome to DreamSpeech [laughter], I hope everyone <strong>has fun</strong></a></li>
                            <li><a class="dropdown-item text-example" href="#">[breath] This is a <strong>special day</strong>, we witness this moment together [sigh]</a></li>
                            <li><a class="dropdown-item text-example" href="#"><laughter>So happy</laughter>, I didn't expect to meet you all here</a></li>
                            <li><a class="dropdown-item text-example" href="#">[breath] I'm so nervous, this is my first time <strong>public speaking</strong></a></li>
                            <li><a class="dropdown-item text-example" href="#">Oh wow [laughter], I thought I had seen it all until now [laughter]. Your ability to surprise never ceases to amaze me [laughter].</a></li>
                        </ul>
                    </div>
                </div>
                <textarea class="form-control" id="inputText" name="text" required
                          placeholder="Enter text here..." rows="10"
                          maxlength="1000"></textarea>
                <div class="d-flex justify-content-between align-items-center mt-2">
                    <small class="text-muted">
                        <i class="fas fa-info-circle me-1"></i><span id="limitMessage">For quality, please limit each generation to 1000 characters. For longer text, generate in parts. Sound effects are not supported.</span>
                        <a href="#" id="refreshMembershipLink" class="ms-2 text-primary" style="font-size: 0.8em; text-decoration: none;" onclick="manualRefreshMembership(); return false;" title="Refresh membership status">
                            <i class="fas fa-sync-alt"></i>
                        </a>
                    </small>
                    <div class="char-counter">
                        <span id="charCount">0</span>/<span id="maxCharCount">1000</span> chars
                    </div>
                </div>
                <button type="submit" class="generate-btn" id="generateBtn"
                        data-is-authenticated="{{ current_user.is_authenticated|tojson|safe }}">
                    <i class="fas fa-magic me-2"></i>Generate DreamSpeech
                </button>
            </div>
        </form>

        <!-- Update Doubao Modal content -->
        <div class="modal fade" id="doubaoModal" tabindex="-1" aria-labelledby="doubaoModalLabel" aria-hidden="true" data-bs-scroll="true" data-bs-backdrop="false">
            <div class="modal-dialog modal-lg modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="left-section">
                            <h5 class="modal-title" id="doubaoModalLabel">
                                <i class="fas fa-feather-alt me-2"></i>Let the Dream Scribe write for you
                            </h5>
                        </div>
                        <div class="right-section">
                            <button type="button" class="btn-clear-chat" id="clearChatBtn">
                                <i class="fas fa-trash-alt"></i>
                                Clear Chat
                            </button>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                    </div>
                    <div class="modal-body">
                        <div id="doubao-chat-messages" class="chat-messages mb-3">
                            <div class="message message-ai">
                                Hello! I'm the <span class="fancy-poetry-hello">Dream Scribe</span>. I can help you create text in various styles. Tell me what kind of story, poem, or dialogue you'd like, and I'll do my best to write it for you.
                            </div>
                        </div>

                        <div class="chat-input-area">
                            <div class="input-group">
                                <textarea class="form-control" id="doubaoPrompt" rows="1"
                                    placeholder="Example: Write a short story about two friends finding a hidden map..."></textarea>
                                <button class="btn" type="button" id="askDoubaoBtn">
                                    <i class="fas fa-paper-plane me-1"></i>Send
                                </button>
                            </div>
                        </div>

                        <div id="doubaoLoading" class="text-center py-4" style="display: none;">
                            <div class="loading-wave">
                                <div class="loading-bar"></div>
                                <div class="loading-bar"></div>
                                <div class="loading-bar"></div>
                                <div class="loading-bar"></div>
                                <div class="loading-bar"></div>
                            </div>
                            <p class="mt-3">The Dream Scribe is thinking...</p>
                        </div>
                    </div>
                    <div class="modal-footer justify-content-between align-items-center">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Hide</button>
                        <small class="text-muted" style="margin: 0 10px;">When creating new content, please click the 'Clear Chat' button first~</small>
                        <button type="button" class="btn btn-light position-relative" id="useLatestResponseBtn" style="display: none;">
                            <i class="fas fa-check me-1"></i>Use Latest Response
                            <span class="position-absolute top-0 start-100 translate-middle pulse-dot"></span>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Add warning modal for sensitive words -->
        <div class="modal fade" id="sensitiveWordModal" tabindex="-1" aria-labelledby="sensitiveWordModalLabel" aria-hidden="true" data-bs-backdrop="false" data-bs-scroll="true">
            <div class="modal-dialog modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="sensitiveWordModalLabel">
                            <i class="fas fa-exclamation-triangle text-warning me-2"></i>Content Warning
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <p>The following sensitive words were detected in your input:</p>
                        <p class="text-danger fw-bold" id="sensitiveWordsList"></p>
                        <p class="text-muted small">To maintain a positive community environment, please revise your text and try again.</p>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Okay</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="loadingSpinner" class="text-center mt-4" style="display: none;">
            <div class="loading-wave">
                <div class="loading-bar"></div>
                <div class="loading-bar"></div>
                <div class="loading-bar"></div>
                <div class="loading-bar"></div>
                <div class="loading-bar"></div>
            </div>
            <p class="mt-3">Generating DreamSpeech, please wait...</p>
        </div>

        <div id="audioContainer" class="audio-player-card" style="display: none;">
            <h4 class="mb-4">Your Custom DreamSpeech</h4>
            <div class="waveform-container">
                <div id="waveform"></div>
            </div>
            <div class="audio-controls">
                <button id="playBtn" class="audio-btn play-btn">
                    <i class="fas fa-play me-2"></i>Play
                </button>
                <a id="downloadBtn" class="audio-btn download-btn text-center text-decoration-none">
                    <i class="fas fa-download me-2"></i>Download
                </a>
            </div>
        </div>
    </div>
</div>

<!-- Modal for managing saved voices -->
<div class="modal fade" id="manageVoicesModal" tabindex="-1" aria-labelledby="manageVoicesModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="manageVoicesModalLabel">Manage Saved Voices</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="saved-voices-container">
                    <div class="alert alert-info mb-3">
                        <i class="fas fa-info-circle me-2"></i>You can save up to 5 voice references. Currently saved: <span id="voiceCountInModal">0</span>/5
                    </div>
                    <div id="noVoicesMessage" class="alert alert-warning" style="display: none;">
                        <i class="fas fa-exclamation-triangle me-2"></i>You haven't saved any voices yet.
                    </div>
                    <div id="savedVoicesList" class="list-group">
                        <!-- List will be populated by JavaScript -->
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/wavesurfer.js/7.7.3/wavesurfer.min.js    "></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js    "></script>
<script>
// Initialize tooltips
const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
const tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
    return new bootstrap.Tooltip(tooltipTriggerEl);
});

// Add notification handling functions
function updateNotificationCount() {
    fetch('/notifications/count')
        .then(response => response.json())
        .then(data => {
            const countBadge = document.getElementById('notificationCount');
            if (data.count > 0) {
                countBadge.textContent = data.count;
                countBadge.style.display = 'inline-block';
            } else {
                countBadge.style.display = 'none';
            }
        });
}

// Function to get post_id for a comment
async function getPostIdForComment(comment_id) {
    try {
        const response = await fetch(`/get_post_id_for_comment/${comment_id}`);
        const data = await response.json();
        return data.post_id;
    } catch (error) {
        console.error('Error getting post_id for comment:', error);
        return null;
    }
}

async function loadNotifications() {
    try {
        const response = await fetch('/notifications');
        const data = await response.json();
        const notificationList = document.getElementById('notificationList');
        notificationList.innerHTML = '';

        if (data.notifications.length === 0) {
            notificationList.innerHTML = '<div class="text-center py-3">No new messages</div>'; // Translated
            return;
        }

        // Create a map to store post IDs for comments to avoid multiple requests
        const commentPostIds = new Map();

        // First, gather all comment IDs that need post IDs
        const commentPromises = data.notifications
            .filter(n => n.comment_id && !n.post_id)
            .map(async n => {
                if (!commentPostIds.has(n.comment_id)) {
                    try {
                        const response = await fetch(`/get_post_id_for_comment/${n.comment_id}`);
                        const data = await response.json();
                        commentPostIds.set(n.comment_id, data.post_id);
                    } catch (error) {
                        console.error('Error fetching post ID:', error);
                        commentPostIds.set(n.comment_id, null);
                    }
                }
            });

        // Wait for all post ID requests to complete
        await Promise.all(commentPromises);

        // Now render all notifications
        for (const notification of data.notifications) {
            let message = '';
            let link = '#';

            switch (notification.type) {
                case 'follow':
                    message = `${notification.sender.username} followed you`; // Translated
                    link = `/user/${notification.sender.id}/profile`;
                    break;
                case 'like':
                    if (notification.comment_id) {
                        message = `${notification.sender.username} liked your comment`; // Translated
                        const post_id = notification.post_id || commentPostIds.get(notification.comment_id);
                        link = `/forum/post/${post_id}#comment-${notification.comment_id}`;
                    } else {
                        message = `${notification.sender.username} liked your post`; // Translated
                        link = `/forum/post/${notification.post_id}`;
                    }
                    break;
                case 'comment':
                    if (notification.comment_id) {
                        message = `${notification.sender.username} replied to your comment`; // Translated
                        const post_id = notification.post_id || commentPostIds.get(notification.comment_id);
                        link = `/forum/post/${post_id}#comment-${notification.comment_id}`;
                    } else {
                        message = `${notification.sender.username} commented on your post`; // Translated
                        link = `/forum/post/${notification.post_id}`;
                    }
                    break;
            }

            const notificationHtml = `
                <a href="${link}" class="dropdown-item py-2 border-bottom" onclick="handleNotificationClick(event, '${link}')">
                    <div class="d-flex align-items-center">
                        <div class="flex-shrink-0">
                            <img src="${notification.sender.avatar_url ? notification.sender.avatar_url : notification.sender.get_avatar()}"
                                 class="rounded-circle"
                                 width="40" height="40"
                                 alt="${notification.sender.username}"
                                 style="object-fit: cover; border: 1px solid rgba(0, 0, 0, 0.1);"
                                 onerror="this.onerror=null; this.src='/static/default_avatar.png';">
                        </div>
                        <div class="flex-grow-1 ms-3">
                            <div class="text-wrap mb-1">${message}</div>
                            <small class="text-muted">${new Date(new Date(notification.created_at).getTime() + 8 * 60 * 60 * 1000).toLocaleString()}</small>
                        </div>
                    </div>
                </a>
            `;
            notificationList.insertAdjacentHTML('beforeend', notificationHtml);
        }
    } catch (error) {
        console.error('Error loading notifications:', error);
        const notificationList = document.getElementById('notificationList');
        notificationList.innerHTML = '<div class="text-center py-3 text-danger">Failed to load messages</div>'; // Translated
    }
}


// Function to handle notification clicks
function handleNotificationClick(event, link) {
    event.preventDefault();
    // Close the dropdown
    const dropdownMenu = document.querySelector('.dropdown-menu');
    if (dropdownMenu) {
        const dropdown = bootstrap.Dropdown.getInstance(document.getElementById('notificationsDropdown'));
        if (dropdown) {
            dropdown.hide();
        }
    }
    // Navigate to the link
    window.location.href = link;
}

// Add styles for notification items
const style = document.createElement('style');
style.textContent = `
    .dropdown-item:hover {
        background-color: rgba(0, 0, 0, 0.05);
    }
    #notificationList .dropdown-item {
        white-space: normal;
        border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }
    #notificationList .dropdown-item:last-child {
        border-bottom: none;
    }
    #notificationList .dropdown-menu {
        max-height: 400px;
        overflow-y: auto;
    }
`;
document.head.appendChild(style);

// Update notification count every minute
setInterval(updateNotificationCount, 60000);

// Load notifications when dropdown is opened
document.getElementById('notificationsDropdown')?.addEventListener('show.bs.dropdown', loadNotifications);

// Initial load
if (document.getElementById('notificationCount')) {
    updateNotificationCount();
}

// Original text-to-speech JavaScript code
let wavesurfer;
let isPlaying = false;

// Configure marked.js
marked.setOptions({
    breaks: true,
    gfm: true,
    headerIds: false,
    mangle: false
});

// Add sensitive words list (English examples)
const sensitiveWords = [
    "fuck", "shit", "cunt", "asshole", "bitch", "damn", "hell", "piss", "cock", "pussy", 'cock', 'penis', 'vagina', 'tits', 'fucks', 'fucker', 'fucking', 'dick',
    'masturbation', 'masterbate', 'orgasm', 'baton', 'selfdefense', 'stungun', 'taser',
    'porn', 'anal', 'anus', 'clit', 'cocksmoker', 'cocksucker', 'cum', 'cumslut',
    'erection', 'pussy', 'g-spot', 'vaginal', 'clitoris', 'nazi'
];

// Function to check for sensitive words and return censored versions
function checkSensitiveWords(text) {
    const foundSensitiveWords = [];
    // Make the check case-insensitive
    const lowerCaseText = text.toLowerCase();
    for (const word of sensitiveWords) {
        // Use regex for whole word matching, case-insensitive
        const regex = new RegExp(`\\b${word}\\b`, 'gi');
        if (regex.test(lowerCaseText)) {
            // Create censored version of the word
            let censoredWord = word;
            if (word.length <= 2) {
                censoredWord = word[0] + '*';
            } else {
                censoredWord = word[0] + '*'.repeat(word.length - 2) + word[word.length - 1];
            }
            // Add only unique censored words
            if (!foundSensitiveWords.includes(censoredWord)) {
                foundSensitiveWords.push(censoredWord);
            }
        }
    }
    return foundSensitiveWords;
}


// Initialize sensitive word modal
const sensitiveWordModal = new bootstrap.Modal(document.getElementById('sensitiveWordModal'));

// Add character counter functionality
const textarea = document.getElementById('inputText');
const charCount = document.getElementById('charCount');
const charCounter = document.querySelector('.char-counter');

function updateCharCount() {
    const inputText = document.getElementById('inputText');
    const charCount = document.getElementById('charCount');
    const maxCharCount = document.getElementById('maxCharCount');
    const length = inputText.value.length;

    charCount.textContent = length;

    // Update color based on length
    const maxLength = parseInt(maxCharCount.textContent);
    const counterElement = document.querySelector('.char-counter');

    counterElement.classList.remove('near-limit', 'at-limit');
    if (length >= maxLength * 0.9) {  // At 90% of max length
        counterElement.classList.add('at-limit');
    } else if (length >= maxLength * 0.8) {  // At 80% of max length
        counterElement.classList.add('near-limit');
    }
}

// Update this function to ensure the membership check is reflected in the UI
function updateMaxLength() {
    const isCustomVoice = document.getElementById('customVoice').checked;
    const isLongTextVoice = document.getElementById('longTextVoice').checked;
    const isMultiSpeakerVoice = document.getElementById('multiSpeakerVoice').checked; // Add this line
    // Use global window.hasMembership instead of local variable
    const hasMembership = window.hasMembership || false;

    // Get the max length based on voice type and membership status
    let maxLength = 1000; // Default for non-specific modes (shouldn't happen)

    // Hide or show the main text input card based on voice source
    const textInputCard = document.querySelector('.text-input-card');
    if (isMultiSpeakerVoice) {
        // For multi-speaker mode, hide the main text input as we use separate textareas
        textInputCard.style.display = 'none';
        return; // No need to continue updating the main input field settings
    } else {
        // For other modes, make sure text input is visible
        textInputCard.style.display = 'block';
    }

    if (isCustomVoice) {
        maxLength = hasMembership ? 300 : 200; // 300 for members, 200 for regular users
    } else if (isLongTextVoice) {
        maxLength = hasMembership ? 1000 : 200; // 1000 for members, 200 for regular users in long text mode
    }

    console.log(`Updating max length: ${maxLength} chars (membership: ${hasMembership ? "ACTIVE" : "INACTIVE"}, tab: ${isCustomVoice ? "Custom" : (isLongTextVoice ? "Long Text" : (isMultiSpeakerVoice ? "Multi Speaker" : "Unknown"))})`);

    const inputText = document.getElementById('inputText');
    const maxCharCount = document.getElementById('maxCharCount');

    // These updates must be made to ensure the UI reflects the correct limits
    inputText.maxLength = maxLength;
    maxCharCount.textContent = maxLength;

    // Also update the character count display
    updateCharCount();

    // Update the limit message
    const limitMessage = document.getElementById('limitMessage');
    if (isCustomVoice) {
        limitMessage.innerHTML = hasMembership ?
            'Member Exclusive: You can enter up to 300 characters. Available effects: [breath] (breath) &#60;strong&#62;emphasized word&#60;/strong&#62; [noise] (noise) [laughter] (laughter) [cough] (cough) [clucking] (cluck) [quick_breath] (quick breath) <laughter>laughing while speaking</laughter> [hissing] (hiss) [sigh] (sigh)' :
            'Using the default model, limit generation to 200 characters for quality. Available effects: [breath] (breath) &#60;strong&#62;emphasized word&#60;/strong&#62; [noise] (noise) [laughter] (laughter) [cough] (cough) [clucking] (cluck) [quick_breath] (quick breath) <laughter>laughing while speaking</laughter> [hissing] (hiss) [sigh] (sigh)';
        console.log("Custom voice message set:", limitMessage.innerHTML.substring(0, 50) + "...");
    } else if (isLongTextVoice) {
        limitMessage.innerHTML = hasMembership ?
            'Member Exclusive: Long text mode supports up to 1000 characters, unlimited usage.' :
            'Members support up to 1000 characters for long text.';
        console.log("Long text message set:", limitMessage.innerHTML);
    } else {
        // This case shouldn't be reachable if multi-speaker hides the card
        limitMessage.textContent = 'For quality, please limit each generation to 1000 characters. For longer text, generate in parts. Sound effects are not supported.';
        console.log("Fallback/unknown voice message set:", limitMessage.textContent);
    }

    // If current text is longer than new max length, truncate it
    if (inputText.value.length > maxLength) {
        inputText.value = inputText.value.substring(0, maxLength);
        updateCharCount();
    }
}

textarea.addEventListener('input', updateCharCount);
textarea.addEventListener('paste', (e) => {
    setTimeout(updateCharCount, 0);
});

// Add voice source toggle functionality
document.addEventListener('DOMContentLoaded', function() {
    // const presetVoice = document.getElementById('presetVoice'); // Removed preset voice option
    const customVoice = document.getElementById('customVoice');
    const longTextVoice = document.getElementById('longTextVoice');
    const multiSpeakerVoice = document.getElementById('multiSpeakerVoice');
    // const presetSection = document.getElementById('presetVoiceSection'); // Removed preset voice section
    const customSection = document.getElementById('customVoiceSection');
    const longTextSection = document.getElementById('longTextSection');
    const multiSpeakerSection = document.getElementById('multiSpeakerSection'); // Added multi-speaker section
    // const modelSelect = document.getElementById('modelSelect'); // Removed model select dropdown
    const audioFile = document.getElementById('audioFile');
    const audioTranscription = document.getElementById('audioTranscription');
    const longTextAudioFile = document.getElementById('longTextAudioFile');
    const longTextTranscription = document.getElementById('longTextTranscription');
    const inputText = document.getElementById('inputText');
    const charCount = document.getElementById('charCount');
    const maxCharCount = document.getElementById('maxCharCount');
    const limitMessage = document.getElementById('limitMessage');
    // Get the custom-voice-only element if it exists
    const customVoiceOnly = document.querySelector('.custom-voice-only');

    // Initialize the file name display functionality
    initFileDisplayNames();

    // Instead of duplicating the updateMaxLength function here,
    // we'll just make sure the global one gets the right elements
    window.updateLocalMaxLength = function() {
        // Call the global updateMaxLength which is already properly defined
        updateMaxLength();
    }

    // This function is now moved to the main DOMContentLoaded event listener
});

// Fix the form submission handler to properly use tts_instruct when useInstructMode is enabled
document.getElementById('ttsForm').addEventListener('submit', async function(e) {
    e.preventDefault();

    const generateBtn = document.getElementById('generateBtn');
    const isAuthenticated = generateBtn.dataset.isAuthenticated === 'true';
    const inputText = document.getElementById('inputText');
    const isCustomVoice = document.getElementById('customVoice').checked;
    const isLongTextVoice = document.getElementById('longTextVoice').checked;
    const isMultiSpeakerVoice = document.getElementById('multiSpeakerVoice').checked;
    const hasMembership = window.hasMembership || false;

    // Authentication check
    if (!isAuthenticated) {
        window.location.href = '/login?next=' + encodeURIComponent('/text-to-speech');
        return;
    }

    // Special handling for multi-speaker mode
    if (isMultiSpeakerVoice) {
        // Multi-speaker submission is handled by its own button's click event
        // This form submit should not trigger multi-speaker generation
        console.log("Form submission triggered, but Multi-Speaker mode is active. Ignoring main generate button.");
        return;
    }

    // Text length check based on voice source and membership status for other modes
    let maxLength = 1000; // Default fallback

    if (isCustomVoice) {
        maxLength = hasMembership ? 300 : 200;
    } else if (isLongTextVoice) {
        maxLength = hasMembership ? 1000 : 200;
    }

    console.log("Form submission check - Mode:", isCustomVoice ? "Custom Voice" : (isLongTextVoice ? "Long Text" : "Unknown"));
    console.log("Form submission check - Membership:", hasMembership ? "Member" : "Free User");
    console.log("Form submission check - Max Length:", maxLength);
    console.log("Form submission check - Current text length:", inputText.value.length);

    if (inputText.value.length > maxLength) {
        alert(`For quality, please limit each generation to ${maxLength} characters.`); // Translated
        return;
    } else if (inputText.value.length === 0) {
        alert('Please enter the text to convert to speech.'); // Translated
        return;
    }

    // Check for sensitive words
    const foundSensitiveWords = checkSensitiveWords(inputText.value);
    if (foundSensitiveWords.length > 0) {
        document.getElementById('sensitiveWordsList').textContent = foundSensitiveWords.join(', '); // Use comma for English list
        const sensitiveWordModal = new bootstrap.Modal(document.getElementById('sensitiveWordModal'));
        sensitiveWordModal.show();
        return;
    }

    // Disable button and show loading state
    generateBtn.disabled = true;
    document.getElementById('loadingSpinner').style.display = 'block';
    document.getElementById('audioContainer').style.display = 'none';
    document.getElementById('errorAlert').style.display = 'none';

    try {
        // Create FormData object for the request
        const formData = new FormData();

        // Add common fields
        formData.append('text', inputText.value);

        let response;
        let endpoint;

        if (isCustomVoice) {
            // Custom voice mode fields
            const audioFile = document.getElementById('audioFile').files[0];
            const audioTranscription = document.getElementById('audioTranscription').value;
            const speedSlider = document.getElementById('speedSlider');
            const useInstructMode = document.getElementById('useInstructMode')?.checked;
            const useAzureTTS = document.getElementById('useAzureTTS')?.checked;
            const emotionSelect = document.getElementById('emotion-select');

            // Check if Azure TTS is enabled
            if (useAzureTTS) {
                // Validate audio file is uploaded even for Azure TTS
                if (!audioFile) {
                    throw new Error('Please upload an audio file as a voice reference.'); // Translated
                }

                // No need to validate transcription for Azure TTS

                // Use the Azure TTS endpoint
                endpoint = '/azure_tts_convert';

                // Add required parameters for Azure TTS - including audio file but NOT transcription
                formData.append('text', inputText.value);
                formData.append('audio_file', audioFile);
                // Don't include transcription for Azure TTS
                formData.append('speed', speedSlider.value);
                formData.append('use_azure_tts', 'true'); // Important flag for the backend

                // Add emotion if selected
                if (emotionSelect && emotionSelect.value !== 'default') {
                    formData.append('emotion', emotionSelect.value);
                } else {
                    // Add default emotion if none selected
                    formData.append('emotion', 'default');
                }

                // Log the request data for debugging
                console.log('Using Azure TTS endpoint with these parameters:', {
                    textLength: inputText.value.length,
                    hasAudioFile: !!audioFile,
                    speed: speedSlider.value,
                    emotion: emotionSelect ? emotionSelect.value : 'default'
                });
            } else if (useInstructMode) {
                // For instruct mode, use the tts_instruct endpoint
                endpoint = '/tts_instruct';

                // Check required parameters
                if (!audioFile) {
                    throw new Error('Please upload an audio file as a voice reference.'); // Translated
                }

                if (!audioTranscription) {
                    // Instruct mode uses transcription field for instructions
                    throw new Error('Please enter voice control instructions.');
                }

                // Add all required parameters with CORRECT parameter names for tts_instruct
                formData.append('audio_file', audioFile); // This parameter name is correct
                formData.append('tts_text', inputText.value); // This should be tts_text, not transcription
                formData.append('instruct_text', audioTranscription); // This should be instruct_text, not text
                formData.append('speed', speedSlider.value); // Speed parameter remains the same

                // Log the request data for debugging
                console.log('Using TTS Instruct endpoint with these parameters:', {
                    instructTextLength: audioTranscription.length,
                    hasAudioFile: !!audioFile,
                    ttsTextLength: inputText.value.length,
                    speed: speedSlider.value
                });
            } else {
                // Use the regular custom TTS endpoint
                endpoint = '/custom_tts';

                if (!audioFile) {
                    throw new Error('Please upload an audio file as a voice reference.'); // Translated
                }

                if (!audioTranscription) {
                    throw new Error('Please enter the text corresponding to the audio.'); // Translated
                }

                formData.append('audio_file', audioFile);
                formData.append('transcription', audioTranscription);
                formData.append('speed', speedSlider.value);
            }

            // Send the request to the appropriate endpoint
            response = await fetch(endpoint, {
                method: 'POST',
                body: formData
            });

        } else if (isLongTextVoice) {
            // Long text mode fields
            const audioFile = document.getElementById('longTextAudioFile').files[0];
            const audioTranscription = document.getElementById('longTextTranscription').value;
            const speedSlider = document.getElementById('longTextSpeedSlider');

            if (!audioFile) {
                throw new Error('Please upload an audio file as a voice reference.'); // Translated
            }

            if (!audioTranscription) {
                throw new Error('Please enter the text corresponding to the audio.'); // Translated
            }

            formData.append('audio_file', audioFile);
            formData.append('transcription', audioTranscription);
            formData.append('speed', speedSlider.value);
            formData.append('is_long_text', 'true');

            // Send the request to the long text endpoint
            response = await fetch('/f5_tts_long_text', {
                method: 'POST',
                body: formData
            });
        }

        if (!response || !response.ok) {
            // Check the content type to handle error responses properly
            const contentType = response.headers.get('content-type');

            // Specially log Azure TTS errors for better debugging
            if (endpoint === '/azure_tts_convert') {
                console.error(`Azure TTS error: Status ${response.status}, Content-Type: ${contentType}`);
                try {
                    // Try to get detailed error information
                    const errorText = await response.text();
                    console.error('Azure TTS error details:', errorText);

                    // Check if it's JSON error response despite the content type
                    try {
                        const errorJson = JSON.parse(errorText);
                        if (errorJson.error) {
                            throw new Error(`Azure TTS Error: ${errorJson.error}`); // Translated
                        }
                    } catch (jsonParseError) {
                        // Not JSON, use the text as error message if it seems useful
                        if (errorText && errorText.length < 200) {
                            throw new Error(`Azure TTS Error: ${errorText}`); // Translated
                        }
                    }

                    // Generic error if we couldn't extract useful info
                    throw new Error(`Azure TTS generation failed (${response.status}): Please check the console log for details.`); // Translated
                } catch (error) {
                    // Throw the error from the try block if it exists
                    throw error;
                }
            }

            // Similarly provide detailed logs for tts_instruct errors
            if (endpoint === '/tts_instruct') {
                console.error(`TTS Instruct error: Status ${response.status}, Content-Type: ${contentType}`);
                try {
                    // Try to get detailed error information
                    const errorText = await response.text();
                    console.error('TTS Instruct error details:', errorText);

                    // Check if it's JSON error response despite the content type
                    try {
                        const errorJson = JSON.parse(errorText);
                        if (errorJson.error) {
                            throw new Error(`Voice Control Error: ${errorJson.error}`); // Translated
                        }
                    } catch (jsonParseError) {
                        // Not JSON, use the text as error message if it seems useful
                        if (errorText && errorText.length < 200) {
                            throw new Error(`Voice Control Error: ${errorText}`); // Translated
                        }
                    }

                    // Generic error if we couldn't extract useful info
                    throw new Error(`Voice Control generation failed (${response.status}): Please check the console log for details.`); // Translated
                } catch (error) {
                    // Throw the error from the try block if it exists
                    throw error;
                }
            }

            // If we got a non-JSON response, handle the error differently
            if (contentType && contentType.includes('text/html')) {
                const errorText = await response.text();
                console.error('Server returned HTML instead of JSON:', errorText.substring(0, 200) + '...');
                throw new Error(`The server returned an incorrect response format (${response.status}). Please check the logs or contact an administrator.`); // Translated
            }

            try {
                const errorData = await response.json();
                // Generic error message for credits/premium
                throw new Error(errorData.error || `Insufficient points. Upgrade to Premium for unlimited access. If already upgraded or sufficient points available, refresh the page or open a new browser and retry.`); // Translated
            } catch (jsonError) {
                throw new Error(`Insufficient points. Upgrade to Premium for unlimited access. If already upgraded or sufficient points available, refresh the page or open a new browser and retry.`); // Translated
            }
        }

        // Try to parse the response as JSON
        let data;
        try {
            data = await response.json();

            if (endpoint === '/azure_tts_convert') {
                console.log('Azure TTS response:', data);
            }

            if (endpoint === '/tts_instruct') {
                console.log('TTS Instruct response:', data);
            }
        } catch (jsonError) {
            console.error('Error parsing JSON response:', jsonError);
            throw new Error('The server returned data in an incorrect format. Please try again later.'); // Translated
        }

        if (!data) {
            throw new Error('Generation failed, server response was empty.'); // Translated
        }

        if (data.error) {
            throw new Error(data.error);
        }

        if (!data.url && !data.audio_url) {
            throw new Error('Reference audio format error. Please change the format, WAV is recommended.'); // Translated
        }

        // Use the appropriate URL field
        const audioUrl = data.url || data.audio_url;

        // Process the response
        finishAudioGeneration(audioUrl);

    } catch (error) {
        console.error('TTS generation error:', error);
        showError(error.message || 'Generation failed. Please try again later.'); // Translated
        document.getElementById('loadingSpinner').style.display = 'none';
    } finally {
        generateBtn.disabled = false;
    }
});


// Helper function to show error messages
function showError(message) {
    document.getElementById('errorMessage').textContent = message;
    const errorAlert = document.getElementById('errorAlert');
    errorAlert.style.display = 'block';

    // Auto-scroll to the error message
    setTimeout(() => {
        errorAlert.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }, 100);
}

// Helper function to process audio URL and initialize audio player
function finishAudioGeneration(audioUrl) {
    const loadingSpinner = document.getElementById('loadingSpinner');
    const audioContainer = document.getElementById('audioContainer');
    const generateBtn = document.getElementById('generateBtn'); // Main generate button
    const multiSpeakerGenerateBtn = document.getElementById('multiSpeakerGenerateBtn'); // Multi-speaker button


    // Initialize WaveSurfer
    if (wavesurfer) {
        wavesurfer.destroy();
    }

    // Before creating WaveSurfer, ensure audioUrl is valid
    if (!audioUrl || typeof audioUrl !== 'string' || audioUrl === '[object Object]') {
        console.error("Invalid audioUrl for WaveSurfer:", audioUrl);
        console.error("audioUrl type:", typeof audioUrl);
        console.error("audioUrl value:", audioUrl);
        showError('Invalid audio URL. Please try refreshing the page.'); // Translated
        loadingSpinner.style.display = 'none';
        if (generateBtn) generateBtn.disabled = false;
        if (multiSpeakerGenerateBtn) multiSpeakerGenerateBtn.disabled = false; // Re-enable multi-speaker button too
        return; // Exit early if URL is invalid
    }

    console.log("Creating WaveSurfer instance for URL:", audioUrl);

    // Create container for wavesurfer if it doesn't exist
    let waveformContainer = document.getElementById('waveform');
    if (!waveformContainer) {
        console.error("Waveform container not found!");
        showError("Audio player container not found. Please refresh the page and try again."); // Translated
        loadingSpinner.style.display = 'none';
        if (generateBtn) generateBtn.disabled = false;
        if (multiSpeakerGenerateBtn) multiSpeakerGenerateBtn.disabled = false;
        return; // Exit early
    }

    wavesurfer = WaveSurfer.create({
        container: '#waveform',
        waveColor: '#4ECDC4',
        progressColor: '#FF6B6B',
        cursorColor: '#2C3E50',
        barWidth: 2,
        barRadius: 3,
        cursorWidth: 1,
        height: 100,
        barGap: 3,
        normalize: true,  // Normalize the waveform
        backend: 'WebAudio'  // Explicitly set the backend
    });

    // Set up error handling for wavesurfer
    wavesurfer.on('error', function(err) {
        console.error('WaveSurfer error:', err);
        showError('Failed to load audio, please retry: ' + err.message); // Translated
        loadingSpinner.style.display = 'none';
        if (generateBtn) generateBtn.disabled = false;
        if (multiSpeakerGenerateBtn) multiSpeakerGenerateBtn.disabled = false;
    });

    // Load the audio and set up the player
    try {
        // Ensure audioUrl is a string before using includes
        if (typeof audioUrl !== 'string') {
            audioUrl = String(audioUrl);
        }

        // Add cache busting parameter if not already present
        if (!audioUrl.includes('?cb=')) {
            const cacheBuster = '?cb=' + new Date().getTime();
            audioUrl = audioUrl + cacheBuster;
        }

        console.log("Loading audio into WaveSurfer:", audioUrl);
        wavesurfer.load(audioUrl);

        // Wait for the audio to load before showing the container
        wavesurfer.on('ready', function() {
            console.log("WaveSurfer ready event triggered");

            document.getElementById('downloadBtn').href = audioUrl;
            document.getElementById('downloadBtn').download = 'generated_speech.wav';
            audioContainer.style.display = 'block';
            loadingSpinner.style.display = 'none';
            if (generateBtn) generateBtn.disabled = false; // Re-enable button
            if (multiSpeakerGenerateBtn) multiSpeakerGenerateBtn.disabled = false; // Re-enable button

            // Scroll to audio container after a short delay to ensure it's rendered
            setTimeout(() => {
                const rect = audioContainer.getBoundingClientRect();
                const isVisible = (
                    rect.top >= 0 &&
                    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight)
                );

                if (!isVisible) {
                    audioContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }, 100);
        });
    } catch (wavesurferError) {
        console.error('Error loading audio into WaveSurfer:', wavesurferError);

        // Try a fallback approach with a regular HTML5 Audio element
        try {
            console.log("Trying fallback with HTML5 Audio element");
            const audioElement = document.createElement('audio');
            audioElement.controls = true;
            audioElement.style.width = '100%';
            audioElement.style.marginTop = '20px';
            audioElement.style.marginBottom = '20px';

            // Add event listeners
            audioElement.addEventListener('canplaythrough', () => {
                console.log("Audio element can play through");
                // Replace the waveform container with our audio element
                const waveformContainer = document.getElementById('waveform');
                waveformContainer.innerHTML = '';
                waveformContainer.appendChild(audioElement);

                // Show controls
                audioContainer.style.display = 'block';
                loadingSpinner.style.display = 'none';
                if (generateBtn) generateBtn.disabled = false;
                if (multiSpeakerGenerateBtn) multiSpeakerGenerateBtn.disabled = false;

                // Set up download button
                document.getElementById('downloadBtn').href = audioUrl;
                document.getElementById('downloadBtn').download = 'generated_speech.wav';

                // Modify play button to control the audio element
                document.getElementById('playBtn').onclick = () => {
                    if (audioElement.paused) {
                        audioElement.play();
                        document.getElementById('playBtn').innerHTML = '<i class="fas fa-pause me-2"></i>Pause'; // Translated
                    } else {
                        audioElement.pause();
                        document.getElementById('playBtn').innerHTML = '<i class="fas fa-play me-2"></i>Play'; // Translated
                    }
                };

                // Scroll to audio container
                setTimeout(() => {
                    const rect = audioContainer.getBoundingClientRect();
                    const isVisible = (
                        rect.top >= 0 &&
                        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight)
                    );

                    if (!isVisible) {
                        audioContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }, 100);
            });

            audioElement.addEventListener('error', (e) => {
                console.error("Audio element error:", e);
                // Don't throw error here, just log it and handle gracefully
                console.error("Audio loading failed: " + (e.message || "Unknown error"));

                // Show error message to user
                showError('Failed to load audio. Please try downloading manually or refresh the page.'); // Translated

                // Make download available
                document.getElementById('downloadBtn').href = audioUrl;
                document.getElementById('downloadBtn').download = 'generated_speech.wav';
            });

            // Set the source and start loading - ensure the URL is valid
            console.log("Setting audio element source to:", audioUrl);
            try {
                // Make sure the URL is valid before setting
                audioElement.src = audioUrl;
            } catch (srcError) {
                console.error("Error setting audio source:", srcError);
                showError('Invalid audio URL. Please try refreshing the page.'); // Translated
            }

        } catch (audioElementError) {
            console.error("Fallback audio element also failed:", audioElementError);
            showError('Failed to load audio. Please try downloading manually or refresh the page.'); // Translated

            // Ensure audioUrl is a proper string before setting it as href
            let downloadUrl = audioUrl;
            if (typeof downloadUrl === 'object' && downloadUrl !== null) {
                // If it's an object, try to get the url property
                if (downloadUrl.url) {
                    downloadUrl = downloadUrl.url;
                } else {
                    console.error("Invalid audioUrl object:", downloadUrl);
                    downloadUrl = '#'; // Set to a safe fallback
                }
            }

            // Still make download available with the proper URL
            document.getElementById('downloadBtn').href = downloadUrl;
            document.getElementById('downloadBtn').download = 'generated_speech.wav';

            audioContainer.style.display = 'block';
            loadingSpinner.style.display = 'none';
            if (generateBtn) generateBtn.disabled = false;
            if (multiSpeakerGenerateBtn) multiSpeakerGenerateBtn.disabled = false;
        }
    }

    // Update play button state
    wavesurfer.on('play', () => {
        document.getElementById('playBtn').innerHTML = '<i class="fas fa-pause me-2"></i>Pause'; // Translated
        isPlaying = true;
    });

    wavesurfer.on('pause', () => {
        document.getElementById('playBtn').innerHTML = '<i class="fas fa-play me-2"></i>Play'; // Translated
        isPlaying = false;
    });

    wavesurfer.on('finish', () => {
        document.getElementById('playBtn').innerHTML = '<i class="fas fa-play me-2"></i>Play'; // Translated
        isPlaying = false;
    });

    // Play button click handler
    document.getElementById('playBtn').onclick = () => {
        wavesurfer.playPause();
    };
}

// Add markdown cleaning function (if needed, currently not used here)

// Handle saved voices functionality
document.addEventListener('DOMContentLoaded', function() {
    const savedVoicesSelect = document.getElementById('savedVoicesSelect');
    const refreshVoicesBtn = document.getElementById('refreshVoicesBtn');

    // Function to load saved voices from the server
    async function loadSavedVoices() {
        try {
            const response = await fetch('/get_saved_voices');
            const data = await response.json();

            if (data.success && data.voices) {
                // Get both dropdown elements
                const savedVoicesSelect = document.getElementById('savedVoicesSelect');
                const longTextSavedVoicesSelect = document.getElementById('longTextSavedVoicesSelect');

                // Function to update a dropdown with voices data
                const updateDropdown = (dropdown) => {
                    if (!dropdown) return;

                    // Clear existing options (except the first one)
                    while (dropdown.options.length > 1) {
                        dropdown.remove(1);
                    }

                    // Add options for each saved voice
                    data.voices.forEach(voice => {
                        const option = document.createElement('option');
                        option.value = voice.id;
                        option.dataset.audioUrl = voice.audio_url;
                        option.dataset.transcription = voice.transcription;

                        // Create a short preview of the transcription
                        const transcriptionPreview = voice.transcription.length > 20
                            ? voice.transcription.substring(0, 17) + '...'
                            : voice.transcription;

                        // Convert time to China timezone (UTC+8)
                        const chinaTime = convertToChinaTime(voice.created_at);

                        option.textContent = `${transcriptionPreview} (${chinaTime})`;
                        dropdown.appendChild(option);
                    });
                };

                // Update both dropdowns
                updateDropdown(savedVoicesSelect);
                updateDropdown(longTextSavedVoicesSelect);

                // Update the voice count in both labels
                const voiceCount = data.voices.length;
                const updateBadge = (labelSelector) => {
                    const label = document.querySelector(labelSelector);
                    if (label && label.querySelector('.badge')) {
                        label.querySelector('.badge').textContent = `(${voiceCount}/5)`;
                    }
                };

                updateBadge('label[for="savedVoicesSelect"]');
                updateBadge('#longTextSavedVoicesSection label');

                // Update the management modal
                updateManagementModal(data.voices);

                // Show or hide the dropdown sections based on whether we have saved voices
                const updateSectionVisibility = (sectionId) => {
                    const section = document.getElementById(sectionId);
                    if (section) {
                        section.style.display = data.voices.length > 0 ? 'block' : 'none';
                    }
                };

                updateSectionVisibility('savedVoicesSection');
                updateSectionVisibility('longTextSavedVoicesSection');
            } else {
                console.error('Failed to load saved voices:', data.error);
            }
        } catch (error) {
            console.error('Error loading saved voices:', error);
        }
    }

    // Function to convert UTC time string to China time (UTC+8)
    function convertToChinaTime(utcTimeStr) {
        try {
            // Parse the UTC time string
            const utcDate = new Date(utcTimeStr);

            // Format with 8 hours added for China time zone
            const options = {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                hour12: false
            };

            // Create a date string with +8 hours
            const chinaDate = new Date(utcDate.getTime() + (8 * 60 * 60 * 1000));
            // Use a locale that fits English formatting better
            return chinaDate.toLocaleString('en-CA', options).replace(', ', ' '); // e.g., 2024-03-15 10:30
        } catch (e) {
            console.error('Error converting time:', e);
            return utcTimeStr; // Return original if conversion fails
        }
    }


    // Function to update the management modal with the saved voices
    function updateManagementModal(voices) {
        const voicesList = document.getElementById('savedVoicesList');
        const noVoicesMessage = document.getElementById('noVoicesMessage');
        const voiceCountInModal = document.getElementById('voiceCountInModal');

        // Clear the current list
        voicesList.innerHTML = '';

        // Update the voice count
        voiceCountInModal.textContent = voices.length;

        // Show/hide the no voices message
        if (voices.length === 0) {
            noVoicesMessage.style.display = 'block';
            voicesList.style.display = 'none';
        } else {
            noVoicesMessage.style.display = 'none';
            voicesList.style.display = 'block';

            // Add each voice to the list
            voices.forEach(voice => {
                const listItem = document.createElement('div');
                listItem.className = 'list-group-item list-group-item-action d-flex justify-content-between align-items-center';
                listItem.dataset.voiceId = voice.id;

                // Create the voice info section
                const voiceInfo = document.createElement('div');
                voiceInfo.className = 'voice-info';

                // Add transcription
                const transcription = document.createElement('p');
                transcription.className = 'mb-1 fw-bold';
                transcription.textContent = voice.transcription;
                voiceInfo.appendChild(transcription);

                // Add date
                const date = document.createElement('small');
                date.className = 'text-muted';
                // Convert UTC time to China time
                const chinaTime = convertToChinaTime(voice.created_at);
                date.textContent = `Saved: ${chinaTime}`; // Translated
                voiceInfo.appendChild(date);

                // Add audio player
                const audioPlayer = document.createElement('audio');
                audioPlayer.controls = true;
                audioPlayer.className = 'mt-2';
                audioPlayer.style.width = '100%';
                audioPlayer.style.maxWidth = '300px';

                const source = document.createElement('source');
                source.src = voice.audio_url;
                source.type = 'audio/wav';
                audioPlayer.appendChild(source);

                voiceInfo.appendChild(audioPlayer);

                listItem.appendChild(voiceInfo);

                // Add delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn btn-sm btn-outline-danger';
                deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                deleteBtn.title = 'Delete this voice'; // Translated
                deleteBtn.addEventListener('click', async function() {
                    if (confirm('Are you sure you want to delete this voice? This action cannot be undone.')) { // Translated
                        await deleteVoice(voice.id);
                    }
                });

                listItem.appendChild(deleteBtn);
                voicesList.appendChild(listItem);
            });
        }
    }

    // Function to delete a voice
    async function deleteVoice(voiceId) {
        try {
            const response = await fetch(`/delete_saved_voice/${voiceId}`, {
                method: 'POST'
            });

            const result = await response.json();

            if (result.success) {
                // Refresh the voices list
                loadSavedVoices();
            } else {
                alert('Deletion failed: ' + (result.error || 'Unknown error')); // Translated
            }
        } catch (error) {
            console.error('Error deleting voice:', error);
            alert('Deletion failed. Please try again later.'); // Translated
        }
    }

    // Function to refresh saved voices without clearing current inputs
    async function refreshSavedVoicesOnly() {
        try {
            const response = await fetch('/get_saved_voices');

            if (!response.ok) {
                throw new Error(`Server responded with status: ${response.status}`);
            }

            const data = await response.json();

            if (data.success && data.voices) {
                // Get both dropdown elements
                const savedVoicesSelect = document.getElementById('savedVoicesSelect');
                const longTextSavedVoicesSelect = document.getElementById('longTextSavedVoicesSelect');

                let latestVoiceId = null;
                let latestTimestamp = 0;

                // Function to update a dropdown with voices data
                const updateDropdown = (dropdown) => {
                    if (!dropdown) return;

                    // Clear existing options (except the first one)
                    while (dropdown.options.length > 1) {
                        dropdown.remove(1);
                    }

                    // Add options for each saved voice
                    data.voices.forEach(voice => {
                        const option = document.createElement('option');
                        option.value = voice.id;
                        option.dataset.audioUrl = voice.audio_url;
                        option.dataset.transcription = voice.transcription;

                        // Create a short preview of the transcription
                        const transcriptionPreview = voice.transcription.length > 20
                            ? voice.transcription.substring(0, 17) + '...'
                            : voice.transcription;

                        // Convert time to China timezone (UTC+8)
                        const chinaTime = convertToChinaTime(voice.created_at);

                        option.textContent = `${transcriptionPreview} (${chinaTime})`;
                        dropdown.appendChild(option);

                        // Keep track of the latest voice (by creation time)
                        const creationTime = new Date(voice.created_at).getTime();
                        if (creationTime > latestTimestamp) {
                            latestTimestamp = creationTime;
                            latestVoiceId = voice.id;
                        }
                    });
                };

                // Update both dropdowns
                updateDropdown(savedVoicesSelect);
                updateDropdown(longTextSavedVoicesSelect);

                // Update the voice count in both labels
                const voiceCount = data.voices.length;
                const updateBadge = (labelSelector) => {
                    const label = document.querySelector(labelSelector);
                    if (label && label.querySelector('.badge')) {
                        label.querySelector('.badge').textContent = `(${voiceCount}/5)`;
                    }
                };

                updateBadge('label[for="savedVoicesSelect"]');
                updateBadge('#longTextSavedVoicesSection label');

                // Update the management modal
                updateManagementModal(data.voices);

                // Show or hide the dropdown sections based on whether we have saved voices
                const updateSectionVisibility = (sectionId) => {
                    const section = document.getElementById(sectionId);
                    if (section) {
                        section.style.display = data.voices.length > 0 ? 'block' : 'none';
                    }
                };

                updateSectionVisibility('savedVoicesSection');
                updateSectionVisibility('longTextSavedVoicesSection');

                return latestVoiceId; // Return the latest voice ID
            } else {
                console.error('Failed to load saved voices:', data.error);
                throw new Error('Failed to load saved voices: ' + (data.error || 'Unknown error'));
            }
        } catch (error) {
            console.error('Error refreshing saved voices:', error);
            throw error; // Rethrow the error to be handled by the caller
        }
    }

    // Load saved voices when the page loads
    loadSavedVoices();

    // Initialize the manage voices modal
    const manageVoicesModal = new bootstrap.Modal(document.getElementById('manageVoicesModal'));

    // Add manage voices button handler
    document.getElementById('manageVoicesBtn').addEventListener('click', function() {
        manageVoicesModal.show();
    });

    // Add refresh button handler
    if (refreshVoicesBtn) {
        refreshVoicesBtn.addEventListener('click', function() {
            refreshVoicesBtn.disabled = true;
            const originalContent = refreshVoicesBtn.innerHTML;
            refreshVoicesBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>';

            // Clear the transcription field
            document.getElementById('audioTranscription').value = '';

            // Clear the file input
            document.getElementById('audioFile').value = '';

            // Hide the preview section
            document.querySelector('#customVoiceSection .preview-section').style.display = 'none';

            // Hide the save button
            document.getElementById('saveVoiceBtn').style.display = 'none';

            // Reset the savedVoicesSelect to the default option
            savedVoicesSelect.selectedIndex = 0;

            loadSavedVoices().finally(() => {
                refreshVoicesBtn.disabled = false;
                refreshVoicesBtn.innerHTML = originalContent;
            });
        });
    }


    // Handle selecting a saved voice
    if (savedVoicesSelect) {
        savedVoicesSelect.addEventListener('change', async function() {
            const selectedOption = this.options[this.selectedIndex];

            if (this.value) { // If a valid option is selected (not the placeholder)
                const audioUrl = selectedOption.dataset.audioUrl;
                const transcription = selectedOption.dataset.transcription;

                // Set the transcription
                document.getElementById('audioTranscription').value = transcription;

                // Fetch the audio file and create a File object
                try {
                    const response = await fetch(audioUrl);
                    if (!response.ok) throw new Error('Failed to fetch audio file');

                    const blob = await response.blob();

                    // Extract the filename from the URL
                    const urlParts = audioUrl.split('/');
                    const filename = urlParts[urlParts.length - 1] || 'saved_voice.wav'; // Add default filename

                    // Create a File object
                    const file = new File([blob], filename, { type: blob.type || 'audio/wav' }); // Use blob type

                    // Create a FileList-like object
                    const dataTransfer = new DataTransfer();
                    dataTransfer.items.add(file);

                    // Set the file input
                    const audioFileInput = document.getElementById('audioFile');
                    audioFileInput.files = dataTransfer.files;

                    // Set up the audio preview directly
                    const audioPreview = document.getElementById('audioPreview');
                    const previewSection = document.querySelector('#customVoiceSection .preview-section');
                    
                    if (audioPreview) {
                        // Create a new object URL for the blob
                        const blobUrl = URL.createObjectURL(blob);
                        
                        // Set the audio source and show the preview section
                        audioPreview.src = blobUrl;
                        
                        if (previewSection) {
                            previewSection.style.display = 'block';
                        }
                        
                        // Show the save button if the user is authenticated
                        const saveVoiceBtn = document.getElementById('saveVoiceBtn');
                        if (saveVoiceBtn) {
                            const generateBtn = document.getElementById('generateBtn');
                            const isAuthenticated = generateBtn && generateBtn.dataset.isAuthenticated === 'true';
                            saveVoiceBtn.style.display = isAuthenticated ? 'block' : 'none';
                        }
                    }

                    // Trigger the change event to update the preview
                    const event = new Event('change', { bubbles: true });
                    audioFileInput.dispatchEvent(event);

                } catch (error) {
                    console.error('Error fetching saved audio:', error);
                    alert('Could not load the saved audio file.'); // Translated
                }
            }
        });
    }

});


// Add this near the start of the script section, after let isPlaying = false;
// Handle example text selection
document.addEventListener('DOMContentLoaded', function() {
    // Get all example text items
    const textExamples = document.querySelectorAll('.text-example');

    // Add click event to each example
    textExamples.forEach(example => {
        example.addEventListener('click', function(e) {
            e.preventDefault();

            // Get the example text (including HTML tags)
            const exampleText = this.innerHTML;

            // Insert into the input text area
            const inputText = document.getElementById('inputText');
            inputText.value = exampleText;

            // Update the character count
            updateCharCount();

            // Close the dropdown
            const doubaoBtnEl = document.getElementById('doubaoBtn');
            const dropdown = bootstrap.Dropdown.getInstance(doubaoBtnEl);
            if (dropdown) {
                dropdown.hide();
            }

            // Focus on the text area
            inputText.focus();
        });
    });
});


// Function to update the audioTranscription placeholder based on instruct mode
function updateTranscriptionPlaceholder() {
    const useInstructMode = document.getElementById('useInstructMode')?.checked; // Added safe check
    const audioTranscription = document.getElementById('audioTranscription');
    const saveVoiceBtn = document.getElementById('saveVoiceBtn');
    const previewSection = document.querySelector('#customVoiceSection .preview-section'); // Scoped to custom voice section

    if (!audioTranscription) return; // Exit if element not found

    if (useInstructMode) {
        audioTranscription.placeholder = "Enter voice control instructions, e.g., extremely happy tone, very fast speed..."; // Translated
        // Always hide save button in instruct mode
        if (saveVoiceBtn) {
            saveVoiceBtn.style.display = 'none';
        }
    } else {
        audioTranscription.placeholder = "Enter the text corresponding to the uploaded audio..."; // Translated
        // Show save button in normal mode only if preview is visible
        if (saveVoiceBtn && previewSection && previewSection.style.display === 'block') {
            saveVoiceBtn.style.display = 'inline-block';
        } else if (saveVoiceBtn) {
            // Ensure save button is hidden if preview is not visible
             saveVoiceBtn.style.display = 'none';
        }
    }
}

// Add event listener to update placeholder when the checkbox is toggled
document.addEventListener('DOMContentLoaded', function() {
    const useInstructModeCheckbox = document.getElementById('useInstructMode');
    if (useInstructModeCheckbox) {
        useInstructModeCheckbox.addEventListener('change', updateTranscriptionPlaceholder);
        // Initialize on page load
        updateTranscriptionPlaceholder();
    }

    // Add event listener for speed slider
    const speedSlider = document.getElementById('speedSlider');
    const speedValue = document.getElementById('speedValue');
    if (speedSlider && speedValue) {
        speedSlider.addEventListener('input', function() {
            speedValue.textContent = parseFloat(this.value).toFixed(2);
        });
        speedValue.textContent = parseFloat(speedSlider.value).toFixed(2); // Initialize value
    }

    // Add event listener for Azure TTS checkbox
    const useAzureTTSCheckbox = document.getElementById('useAzureTTS');
    if (useAzureTTSCheckbox) {
        useAzureTTSCheckbox.addEventListener('change', function() {
            const audioTranscription = document.getElementById('audioTranscription');
            const transcriptionLabel = document.querySelector('label[for="audioTranscription"]');
            const useInstructMode = document.getElementById('useInstructMode');
            const limitMessage = document.getElementById('limitMessage');
            const isCustomVoice = document.getElementById('customVoice').checked;
            const emotionContainer = document.getElementById('emotionSelectContainer');
            const speedSliderContainer = document.querySelector('label[for="speedSlider"]').closest('.mb-3');

            if (this.checked) {
                // If Azure TTS is checked, disable instruct mode checkbox and gray out transcription
                useInstructMode.checked = false;
                useInstructMode.disabled = true;
                audioTranscription.disabled = true;
                audioTranscription.placeholder = "Text content is not required when using the DreamSpeech Multilingual Model. It offers high naturalness, fast synthesis, and supports over 80 languages..."; // Translated
                transcriptionLabel.classList.add('text-muted');

                // Update the transcription label to indicate it's not required
                const originalLabelText = transcriptionLabel.innerHTML;
                if (!originalLabelText.includes("(Optional)")) { // Translated check
                    transcriptionLabel.innerHTML = transcriptionLabel.innerHTML.replace("Enter the corresponding text for the audio", "Enter the corresponding text for the audio (Optional)"); // Translated
                }

                // Update the limit message for Azure TTS mode
                limitMessage.innerHTML = 'With the DreamSpeech Multilingual Model, you can use <code>&lt;break strength="medium"/&gt;</code> to add pauses. It offers high naturalness, fast synthesis, supports 80+ languages, but does not support sound effects.'; // Translated

                // Always keep emotion selector hidden and set to default
                if (emotionContainer) {
                    emotionContainer.style.setProperty('display', 'none', 'important');
                    document.getElementById('emotion-select').value = 'default';
                }

                // Make sure speed slider is visible for Azure TTS
                if (speedSliderContainer) {
                    speedSliderContainer.style.display = 'block';
                }
            } else {
                // If Azure TTS is unchecked, enable instruct mode checkbox and transcription
                useInstructMode.disabled = false;
                audioTranscription.disabled = false;
                updateTranscriptionPlaceholder();
                transcriptionLabel.classList.remove('text-muted');

                // Reset the transcription label to original state
                transcriptionLabel.innerHTML = transcriptionLabel.innerHTML.replace("Enter the corresponding text for the audio (Optional)", "Enter the corresponding text for the audio"); // Translated

                // Restore the original limit message based on the current voice source
                updateMaxLength();

                // Hide emotion selector
                if (emotionContainer) {
                    emotionContainer.style.setProperty('display', 'none', 'important');
                }

                // Make sure speed slider is visible
                if (speedSliderContainer) {
                    speedSliderContainer.style.display = 'block';
                }
            }
        });
        // Trigger change on load if already checked
        if (useAzureTTSCheckbox.checked) {
            useAzureTTSCheckbox.dispatchEvent(new Event('change'));
        }
    }
});


// Override the membership activation form submission to prevent page redirects
document.addEventListener('DOMContentLoaded', function() {
    const activateKeyForm = document.getElementById('activateKeyForm');
    if (activateKeyForm) {
        // Remove the existing form action to prevent direct submissions
        activateKeyForm.removeAttribute('action');
        activateKeyForm.removeAttribute('method');

        // Set iframe as target to prevent page reload (if hidden frame exists)
        // activateKeyForm.target = "hiddenFrame"; // Commented out as hiddenFrame might not exist

        // Override the form's submit event
        activateKeyForm.addEventListener('submit', function(e) {
            e.preventDefault();

            const activationKey = document.getElementById('activationKey').value.trim();
            const activateBtn = document.getElementById('activateKeyBtn');

            if (!activationKey) {
                alert('Please enter the activation key.'); // Translated
                return;
            }

            // Disable button and show loading
            activateBtn.disabled = true;
            activateBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Activating...'; // Translated

            // Log activation attempt
            console.log('Attempting to activate key:', activationKey);

            // Create form data
            const formData = new FormData();
            formData.append('activation_key', activationKey);

            // Get CSRF token if available
            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');

            // Submit using fetch API
            fetch('/activate_membership', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    // Try to parse error first
                    return response.json().then(errData => {
                         throw new Error(errData.message || `Server responded with status: ${response.status}`);
                    }).catch(() => {
                         throw new Error(`Server responded with status: ${response.status}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                // Handle successful activation
                console.log('Activation response:', data);

                // Reset button state
                activateBtn.disabled = false;
                activateBtn.innerHTML = '<i class="fas fa-check-circle me-1"></i>Activate'; // Translated

                if (data.success) {
                    // Set membership status immediately
                    window.hasMembership = true;
                    console.log("Membership status updated after activation: MEMBER");

                    // Update the UI to reflect new limits
                    updateMaxLength();

                    // Refresh membership status from server (redundant but safe)
                    checkMembershipStatus();

                    // Show success modal
                    document.getElementById('successMessage').textContent = data.message || 'Your membership has been successfully activated!'; // Translated
                    document.getElementById('membershipDetails').textContent = `Membership days remaining: ${data.days_remaining} days`; // Translated

                    // Hide membership modal and show success modal
                    const membershipModalEl = document.getElementById('membershipModal');
                    if (membershipModalEl) {
                        const membershipModal = bootstrap.Modal.getInstance(membershipModalEl);
                        if (membershipModal) membershipModal.hide();
                    }


                    // Show success modal
                    const successModalEl = document.getElementById('activationSuccessModal');
                     if (successModalEl) {
                        const successModal = new bootstrap.Modal(successModalEl);
                         successModal.show();
                     }


                    // Update membership display if function exists
                    if (typeof updateMembershipDisplay === 'function') {
                        updateMembershipDisplay(true, data.days_remaining);
                    }

                    // Clear the input
                    document.getElementById('activationKey').value = '';
                } else {
                    // Show error message
                    alert(data.message || 'Activation failed. Please check if the activation key is correct.'); // Translated
                }
            })
            .catch(error => {
                console.error('Error activating membership:', error);

                // Reset button state
                activateBtn.disabled = false;
                activateBtn.innerHTML = '<i class="fas fa-check-circle me-1"></i>Activate'; // Translated

                // Show error message
                alert(error.message || 'An error occurred during activation. Please try again later.'); // Translated
            });
        });
    }
});


// Add this at the start of the DOMContentLoaded event handler to ensure the emotion container is hidden on page load
document.addEventListener('DOMContentLoaded', function() {
    // Ensure emotion container is hidden on page load
    const emotionContainer = document.getElementById('emotionSelectContainer');
    const useAzureTTS = document.getElementById('useAzureTTS');

    if (emotionContainer) {
        emotionContainer.style.setProperty('display', 'none', 'important');

        // Only show if checkbox is already checked (in case of page refresh)
        if (useAzureTTS && useAzureTTS.checked) {
            emotionContainer.style.setProperty('display', 'flex', 'important'); // Use flex display
        }
    }

    // Rest of the existing DOMContentLoaded code...
});


// Add event listener for long text speed slider
document.addEventListener('DOMContentLoaded', function() {
    // Add event listener for speed slider
    const speedSlider = document.getElementById('speedSlider');
    const speedValue = document.getElementById('speedValue');
    if (speedSlider && speedValue) {
        speedSlider.addEventListener('input', function() {
            speedValue.textContent = parseFloat(this.value).toFixed(2);
        });
         speedValue.textContent = parseFloat(speedSlider.value).toFixed(2); // Initialize
    }

    // Add event listener for long text speed slider
    const longTextSpeedSlider = document.getElementById('longTextSpeedSlider');
    const longTextSpeedValue = document.getElementById('longTextSpeedValue');
    if (longTextSpeedSlider && longTextSpeedValue) {
        longTextSpeedSlider.addEventListener('input', function() {
            longTextSpeedValue.textContent = parseFloat(this.value).toFixed(2);
        });
        longTextSpeedValue.textContent = parseFloat(longTextSpeedSlider.value).toFixed(2); // Initialize
    }

     // Add event listener for multi-speaker speed slider
    const multiSpeakerSpeedSlider = document.getElementById('multiSpeakerSpeedSlider');
    const multiSpeakerSpeedValue = document.getElementById('multiSpeakerSpeedValue');
    if (multiSpeakerSpeedSlider && multiSpeakerSpeedValue) {
        multiSpeakerSpeedSlider.addEventListener('input', function() {
            multiSpeakerSpeedValue.textContent = parseFloat(this.value).toFixed(2);
        });
        multiSpeakerSpeedValue.textContent = parseFloat(multiSpeakerSpeedSlider.value).toFixed(2); // Initialize
    }
});


// Main document initialization
document.addEventListener('DOMContentLoaded', function() {
    console.log("DOM fully loaded - starting initialization...");

    // Set a default membership status first, in case other checks fail
    if (typeof window.hasMembership === 'undefined') {
        window.hasMembership = false;
        console.log("Setting initial default membership status: FREE USER");
    }

    // Run an immediate membership check to ensure we have the correct status
    console.log("Running initial membership check...");
    checkMembershipStatus(); // This now also calls updateMaxLength

    // Elements
    const customVoice = document.getElementById('customVoice');
    const longTextVoice = document.getElementById('longTextVoice');
    const multiSpeakerVoice = document.getElementById('multiSpeakerVoice');
    const customSection = document.getElementById('customVoiceSection');
    const longTextSection = document.getElementById('longTextSection');
    const multiSpeakerSection = document.getElementById('multiSpeakerSection');
    const audioFile = document.getElementById('audioFile');
    const audioTranscription = document.getElementById('audioTranscription');
    const longTextAudioFile = document.getElementById('longTextAudioFile');
    const longTextTranscription = document.getElementById('longTextTranscription');
    const emotionContainer = document.getElementById('emotionSelectContainer');
    const useAzureTTS = document.getElementById('useAzureTTS');
    const doubaoBtn = document.querySelector('.creative-ai-btn.custom-voice-only');

    // Initialize event listeners for radio buttons
    customVoice.addEventListener('change', toggleVoiceSource);
    longTextVoice.addEventListener('change', toggleVoiceSource);
    multiSpeakerVoice.addEventListener('change', toggleVoiceSource);

    // Call toggleVoiceSource on page load to ensure correct initial state
    toggleVoiceSource();

    // Ensure emotion container is hidden on page load unless Azure TTS is checked
    if (emotionContainer) {
        emotionContainer.style.setProperty('display', 'none', 'important');
        if (useAzureTTS && useAzureTTS.checked) {
            emotionContainer.style.setProperty('display', 'flex', 'important');
        }
    }

    // Azure TTS checkbox setup
    if (useAzureTTS) {
        useAzureTTS.addEventListener('change', function() {
            const audioTranscription = document.getElementById('audioTranscription');
            const transcriptionLabel = document.querySelector('label[for="audioTranscription"]');
            const useInstructMode = document.getElementById('useInstructMode');
            const limitMessage = document.getElementById('limitMessage');
            const emotionContainer = document.getElementById('emotionSelectContainer');
            const speedSliderContainer = document.querySelector('label[for="speedSlider"]').closest('.mb-3');

            if (this.checked) {
                useInstructMode.checked = false;
                useInstructMode.disabled = true;
                audioTranscription.disabled = true;
                audioTranscription.placeholder = "Text content is not required when using the DreamSpeech Multilingual Model. It offers high naturalness, fast synthesis, and supports over 80 languages...";
                transcriptionLabel.classList.add('text-muted');
                if (!transcriptionLabel.innerHTML.includes("(Optional)")) {
                    transcriptionLabel.innerHTML = transcriptionLabel.innerHTML.replace("Enter the corresponding text for the audio", "Enter the corresponding text for the audio (Optional)");
                }
                limitMessage.innerHTML = 'With the DreamSpeech Multilingual Model, you can use <code>&lt;break strength="medium"/&gt;</code> to add pauses. It offers high naturalness, fast synthesis, supports 80+ languages, but does not support sound effects.';
                if (emotionContainer) {
                     emotionContainer.style.setProperty('display', 'none', 'important'); // Keep hidden
                    document.getElementById('emotion-select').value = 'default';
                }
                if (speedSliderContainer) speedSliderContainer.style.display = 'block';
            } else {
                useInstructMode.disabled = false;
                audioTranscription.disabled = false;
                updateTranscriptionPlaceholder();
                transcriptionLabel.classList.remove('text-muted');
                transcriptionLabel.innerHTML = transcriptionLabel.innerHTML.replace("Enter the corresponding text for the audio (Optional)", "Enter the corresponding text for the audio");
                updateMaxLength(); // Restore limit message
                if (emotionContainer) emotionContainer.style.setProperty('display', 'none', 'important');
                if (speedSliderContainer) speedSliderContainer.style.display = 'block';
            }
        });
        // Trigger initial state if checked
        if (useAzureTTS.checked) useAzureTTS.dispatchEvent(new Event('change'));
    }


    // Initialize instruct mode checkbox
    const useInstructModeCheckbox = document.getElementById('useInstructMode');
    if (useInstructModeCheckbox) {
        useInstructModeCheckbox.addEventListener('change', updateTranscriptionPlaceholder);
        updateTranscriptionPlaceholder(); // Initialize on page load
    }

    // Handle audio file upload preview for long text section
    const longTextAudioPreview = document.getElementById('longTextAudioPreview');
    const longTextPreviewSection = document.querySelector('#longTextSection .preview-section');

    if (longTextAudioFile && longTextPreviewSection) {
        longTextAudioFile.addEventListener('change', function(e) {
            const file = e.target.files[0];
             const longTextSaveVoiceBtn = document.getElementById('longTextSaveVoiceBtn'); // Get save button

            if (file) {
                // Create audio element to check duration
                const audio = new Audio();
                const url = URL.createObjectURL(file);
                audio.src = url;

                audio.addEventListener('loadedmetadata', function() {
                    const duration = audio.duration;
                    URL.revokeObjectURL(url); // Revoke object URL after use
                    if (duration < 3 || duration > 15) {
                        // Invalid duration - clear the input and show error
                        longTextAudioFile.value = '';
                        longTextPreviewSection.style.display = 'none';
                        if(longTextSaveVoiceBtn) longTextSaveVoiceBtn.style.display = 'none'; // Hide save button
                        alert(`Audio length must be between 3 and 15 seconds. Current length is ${duration.toFixed(1)} seconds.`); // Translated
                        return;
                    }

                    // Valid duration - show preview
                    if (longTextAudioPreview) {
                        longTextAudioPreview.src = URL.createObjectURL(file); // Create new URL for preview
                        longTextPreviewSection.style.display = 'block';
                        if(longTextSaveVoiceBtn) {
                             const generateBtn = document.getElementById('generateBtn');
                             const isAuthenticated = generateBtn && generateBtn.dataset.isAuthenticated === 'true';
                             longTextSaveVoiceBtn.style.display = isAuthenticated ? 'block' : 'none';
                        }
                    }
                });

                audio.addEventListener('error', function() {
                    URL.revokeObjectURL(url); // Revoke object URL on error
                    // Error loading audio
                    longTextAudioFile.value = '';
                    longTextPreviewSection.style.display = 'none';
                    if(longTextSaveVoiceBtn) longTextSaveVoiceBtn.style.display = 'none'; // Hide save button
                    alert('Cannot read the audio file. Please ensure the format is correct.'); // Translated
                });
            } else {
                longTextPreviewSection.style.display = 'none';
                 if(longTextSaveVoiceBtn) longTextSaveVoiceBtn.style.display = 'none';
            }
        });
    }

    // Complete initialization sequence
    console.log("Running initialization sequence...");

    // Initialize character counter
    updateCharCount();

    // Set up regular checking of membership status to keep it up to date
    setInterval(checkMembershipStatus, 60000); // Check every minute

    // Then initialize UI (but don't call updateMaxLength again, checkMembershipStatus will do that)
    setTimeout(() => {
        // Initialize UI based on the selected tab
        toggleVoiceSource();

        console.log("UI initialized with membership status:", window.hasMembership ? "MEMBER" : "FREE USER");
        console.log("Initialization complete!");
    }, 100);

     // Initialize multi-speaker features
    initializeMultiSpeakerFeatures();

    // Call points reset function on page load
    resetPointsIfNewDay();

    // Also add it to an interval to check regularly
    setInterval(resetPointsIfNewDay, 60000); // Check every minute
});

// Function to check membership status and update UI accordingly
function checkMembershipStatus() {
    fetch('/get_membership_status', {
        method: 'GET',
        headers: {
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache',
            'Expires': '0'
        },
        credentials: 'same-origin'
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Set global variable for membership status
            const oldMembershipStatus = window.hasMembership;
            window.hasMembership = data.has_membership;
            console.log("Membership status retrieved successfully:", window.hasMembership ? "MEMBER" : "FREE USER");

            // Update the max length based on the current tab and membership status
            updateMaxLength();

            // Update the membership display in nav bar and modals
            if (typeof updateMembershipDisplay === 'function') {
                updateMembershipDisplay(data.has_membership, data.days_remaining);
            } else {
                // Use our fallback function if the global one isn't available
                updateMembershipUI(data.has_membership, data.days_remaining);
            }

            // Dispatch event if status changed
            if (oldMembershipStatus !== window.hasMembership) {
                 document.dispatchEvent(new CustomEvent('membershipStatusChanged'));
            }

        } else {
            console.error("Server returned success: false when checking membership");
            window.hasMembership = false;
            updateMaxLength();

            // Update UI to show non-member status
            if (typeof updateMembershipDisplay === 'function') {
                updateMembershipDisplay(false, 0);
            } else {
                updateMembershipUI(false, 0);
            }
            // Dispatch event if status changed
            document.dispatchEvent(new CustomEvent('membershipStatusChanged'));
        }
    })
    .catch(error => {
        console.error('Error checking membership status:', error);
        // Don't retry here, rely on interval check
        // Default to non-member in case of persistent error
        if (typeof window.hasMembership === 'undefined') { // Only if not set previously
            window.hasMembership = false;
            console.log("Setting default membership status to FREE USER due to error");
            updateMaxLength();
            if (typeof updateMembershipDisplay === 'function') {
                updateMembershipDisplay(false, 0);
            } else {
                updateMembershipUI(false, 0);
            }
            // Dispatch event if status changed
            document.dispatchEvent(new CustomEvent('membershipStatusChanged'));
        }
    });
}


// Function to toggle between voice source tabs
function toggleVoiceSource() {
    const customVoice = document.getElementById('customVoice');
    const longTextVoice = document.getElementById('longTextVoice');
    const multiSpeakerVoice = document.getElementById('multiSpeakerVoice');
    const customSection = document.getElementById('customVoiceSection');
    const longTextSection = document.getElementById('longTextSection');
    const multiSpeakerSection = document.getElementById('multiSpeakerSection');
    const audioFile = document.getElementById('audioFile');
    const audioTranscription = document.getElementById('audioTranscription');
    const longTextAudioFile = document.getElementById('longTextAudioFile');
    const longTextTranscription = document.getElementById('longTextTranscription');
    const doubaoBtn = document.querySelector('.creative-ai-btn.custom-voice-only');
    const textInputCard = document.querySelector('.text-input-card'); // Get the main text input card

    if (customVoice.checked) {
        customSection.style.display = 'block';
        longTextSection.style.display = 'none';
        multiSpeakerSection.style.display = 'none';
        textInputCard.style.display = 'block'; // Show main text input
        audioFile.required = true;
        // Transcription required only if instruct mode is off AND Azure TTS is off
        const useInstructMode = document.getElementById('useInstructMode')?.checked;
        const useAzureTTS = document.getElementById('useAzureTTS')?.checked;
        audioTranscription.required = !useInstructMode && !useAzureTTS;
        longTextAudioFile.required = false;
        longTextTranscription.required = false;
        if (doubaoBtn) doubaoBtn.style.display = 'block';
    } else if (longTextVoice.checked) {
        customSection.style.display = 'none';
        longTextSection.style.display = 'block';
        multiSpeakerSection.style.display = 'none';
        textInputCard.style.display = 'block'; // Show main text input
        audioFile.required = false;
        audioTranscription.required = false;
        longTextAudioFile.required = true;
        longTextTranscription.required = true;
        if (doubaoBtn) doubaoBtn.style.display = 'none';
    } else if (multiSpeakerVoice.checked) {
        customSection.style.display = 'none';
        longTextSection.style.display = 'none';
        multiSpeakerSection.style.display = 'block';
        textInputCard.style.display = 'none'; // Hide main text input
        audioFile.required = false;
        audioTranscription.required = false;
        longTextAudioFile.required = false;
        longTextTranscription.required = false;
        if (doubaoBtn) doubaoBtn.style.display = 'none';

        // Load saved voices into all speaker dropdowns if not already loaded
        if (document.querySelectorAll('.speaker-voice-select')[0].options.length <= 1) {
            console.log("Multi-speaker tab selected, initializing voice dropdowns...");
            setTimeout(loadSavedVoicesForSpeakers, 100); // Short delay
        }
        // Update visibility based on membership
        updateMultiSpeakerVisibility();
    }

    // Update text length limits and info messages based on selected tab
    updateMaxLength();
}

// Add a function to manually refresh membership status and update UI
function manualRefreshMembership() {
    // Clear any cached status
    window.hasMembership = undefined;

    // Show loading indicator
    const limitMessage = document.getElementById('limitMessage');
    const refreshLink = document.getElementById('refreshMembershipLink');
    const originalMessageHTML = limitMessage.innerHTML; // Store original HTML
    const icon = refreshLink.querySelector('i');
    icon.classList.add('fa-spin'); // Add spin animation

    // Use checkMembershipStatus which already handles fetch and UI updates
    checkMembershipStatus();

    // Reset icon after a short delay (assuming checkMembershipStatus finishes quickly)
    setTimeout(() => {
        icon.classList.remove('fa-spin');
        // Show status alert based on the updated window.hasMembership
         const hasMembership = window.hasMembership; // Get the potentially updated status
         const daysRemaining = window.membershipDaysRemaining || 0; // Use a global if set by checkMembershipStatus

         if (typeof hasMembership !== 'undefined') { // Check if status was successfully retrieved
             if (hasMembership) {
                 alert(`Membership status refreshed: Your membership is valid for ${daysRemaining} more days.`); // Translated
             } else {
                 alert('Membership status refreshed: You are currently not a member.'); // Translated
             }
         } else {
            // Error case already handled by checkMembershipStatus console logs
             alert('Failed to refresh membership status. Please try again later.'); // Translated
         }
    }, 1500); // Adjust delay if needed
}


// Backup function to update membership UI elements if updateMembershipDisplay isn't available
function updateMembershipUI(hasMembership, daysRemaining) {
    window.membershipDaysRemaining = daysRemaining; // Store for manual refresh alert
    const membershipIndicator = document.getElementById('membershipIndicator');
    const activateMembership = document.getElementById('activateMembership');
    const membershipStatusDisplay = document.getElementById('membershipStatusDisplay');
    const btnMembership = document.querySelector('.btn-membership');

    if (hasMembership) {
        // Update nav button
        if (membershipIndicator) {
            membershipIndicator.innerHTML = `<i class="fas fa-crown text-warning me-1"></i> Membership: ${daysRemaining} days`; // Translated
            membershipIndicator.classList.remove('d-none');
        }
        if (activateMembership) {
            activateMembership.classList.add('d-none');
        }
        if (btnMembership) {
            btnMembership.classList.add('active');
        }

        // Update modal content
        if (membershipStatusDisplay) {
            membershipStatusDisplay.innerHTML = `
                <div class="text-center mb-4">
                    <div class="display-1 text-warning mb-2">
                        <i class="fas fa-crown"></i>
                    </div>
                    <h4 class="mb-2">Membership Active</h4>
                    <div class="bg-light rounded py-2 px-3 d-inline-block">
                        <i class="fas fa-calendar-alt me-2 text-primary"></i>
                        Days Remaining: <span class="fw-bold text-primary">${daysRemaining}</span> days
                    </div>
                </div>
            `; // Translated
        }
    } else {
        // Update nav button for non-members
        if (membershipIndicator) {
            membershipIndicator.classList.add('d-none');
        }
        if (activateMembership) {
            activateMembership.classList.remove('d-none');
        }
        if (btnMembership) {
            btnMembership.classList.remove('active');
        }

        // Update modal content for non-members
        if (membershipStatusDisplay) {
            membershipStatusDisplay.innerHTML = `
                <div class="text-center mb-4">
                    <h4 class="mb-3">Premium Membership</h4>
                    <p class="text-muted">Activate Premium for unlimited access to all services, no credit limits.</p>
                </div>
            `; // Translated (generic)
        }
    }
}

// Add a function to handle audio file uploads and display preview (for Default Model tab)
function handleAudioFileChange(e) {
    const file = e.target.files[0];
    const previewSection = document.querySelector('#customVoiceSection .preview-section'); // Scope to section
    const audioPreview = document.getElementById('audioPreview');
    const saveVoiceBtn = document.getElementById('saveVoiceBtn');

    if (file) {
        // Create object URL for preview
        const audioUrl = URL.createObjectURL(file);

        // Set the audio source
        if (audioPreview) {
            // Remove existing source elements
            while (audioPreview.firstChild) {
                audioPreview.removeChild(audioPreview.firstChild);
            }

            // Create and add new source element
            const source = document.createElement('source');
            source.src = audioUrl;
            source.type = file.type || 'audio/wav';
            audioPreview.appendChild(source);

            // Force reload of audio element
            audioPreview.load();

            // Show the preview section
            if (previewSection) {
                previewSection.style.display = 'block';
            }

            // Show save button if user is authenticated and not in instruct mode
             const useInstructMode = document.getElementById('useInstructMode')?.checked;
            if (saveVoiceBtn && !useInstructMode) {
                const generateBtn = document.getElementById('generateBtn');
                const isAuthenticated = generateBtn && generateBtn.dataset.isAuthenticated === 'true';
                if (isAuthenticated) {
                    saveVoiceBtn.style.display = 'block';
                }
            } else if (saveVoiceBtn) {
                 saveVoiceBtn.style.display = 'none'; // Hide if instruct mode is on
            }


            // Add event listener to check audio duration once metadata is loaded
            audioPreview.onloadedmetadata = function() { // Use onloadedmetadata for reliability
                const duration = audioPreview.duration;
                // No need to revoke URL here, keep it for the player
                if (duration < 3 || duration > 15) {
                    // Show warning if duration is not in the acceptable range
                    alert(`Audio length should be between 3 and 15 seconds. Current length is ${duration.toFixed(1)} seconds.`); // Translated
                     // Optionally clear the input if invalid?
                    // e.target.value = ''; // Clear file input
                    // previewSection.style.display = 'none';
                    // if(saveVoiceBtn) saveVoiceBtn.style.display = 'none';
                }
            };
            audioPreview.onerror = function() {
                 URL.revokeObjectURL(audioUrl); // Revoke on error too
                 alert('Error loading audio preview.');
                 previewSection.style.display = 'none';
                 if(saveVoiceBtn) saveVoiceBtn.style.display = 'none';
            };

        }
    } else {
        // Hide preview if no file is selected
        if (previewSection) {
            previewSection.style.display = 'none';
        }

        // Hide save button
        if (saveVoiceBtn) {
            saveVoiceBtn.style.display = 'none';
        }
    }
}

// Add event listener for audio file input
document.addEventListener('DOMContentLoaded', function() {
    const audioFileInput = document.getElementById('audioFile');
    if (audioFileInput) {
        audioFileInput.addEventListener('change', handleAudioFileChange);
    }

    // Add event listener for save voice button (Default Model)
    const saveVoiceBtn = document.getElementById('saveVoiceBtn');
    if (saveVoiceBtn) {
        saveVoiceBtn.addEventListener('click', function() {
            const audioFile = document.getElementById('audioFile').files[0];
            const transcription = document.getElementById('audioTranscription').value;

            if (!audioFile) {
                alert('Please upload an audio file first.'); // Translated
                return;
            }

            if (!transcription || transcription.trim() === '') {
                alert('Please enter the text corresponding to the audio.'); // Translated
                return;
            }

            // Use the transcription as the voice name instead of asking the user
            const voiceName = transcription.length > 20
                ? transcription.substring(0, 17) + '...'
                : transcription;

            // Disable button and show loading state
            saveVoiceBtn.disabled = true;
            const originalText = saveVoiceBtn.innerHTML;
            saveVoiceBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Saving...'; // Translated

            // Create form data
            const formData = new FormData();
            formData.append('audio_file', audioFile);
            formData.append('transcription', transcription);
            formData.append('voice_name', voiceName);

            // Submit using fetch API
            fetch('/save_voice_reference', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                     // Try to parse error first
                    return response.json().then(errData => {
                         throw new Error(errData.message || `Server responded with status: ${response.status}`);
                    }).catch(() => {
                         throw new Error(`Server responded with status: ${response.status}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                // Reset button
                saveVoiceBtn.disabled = false;
                saveVoiceBtn.innerHTML = originalText;

                if (data.success) {
                    // Show success message
                    alert('Voice saved successfully! You can use it after refreshing.'); // Translated

                    // Update the saved voices dropdown if it exists
                    const savedVoicesSelect = document.getElementById('savedVoicesSelect');
                    if (savedVoicesSelect) {
                        try {
                            // Call the existing function to refresh saved voices
                            refreshSavedVoicesOnly().then(latestVoiceId => {
                                // Select the latest voice if available
                                if (latestVoiceId) {
                                    savedVoicesSelect.value = latestVoiceId;

                                    // Trigger change event to update UI
                                    const event = new Event('change', { bubbles: true });
                                    savedVoicesSelect.dispatchEvent(event);
                                }
                            }).catch(err => {
                                console.error('Error updating saved voices list:', err);
                            });
                        } catch (updateError) {
                            console.error('Error updating saved voices UI:', updateError);
                            // We still show success because the voice was saved
                        }
                    }
                } else {
                    // Show error message
                    alert(data.message || 'Failed to save voice. Please try again later.'); // Translated
                }
            })
            .catch(error => {
                console.error('Error saving voice:', error);
                saveVoiceBtn.disabled = false;
                saveVoiceBtn.innerHTML = originalText;
                alert(error.message || 'An error occurred while saving the voice. Please try again later.'); // Translated
            });
        });
    }

});


// Handle long text audio file uploads
function handleLongTextAudioFileChange(e) {
    const file = e.target.files[0];
    const previewSection = document.querySelector('#longTextSection .preview-section');
    const audioPreview = document.getElementById('longTextAudioPreview');
    const saveVoiceBtn = document.getElementById('longTextSaveVoiceBtn');

    if (file) {
        // Create object URL for preview
        const audioUrl = URL.createObjectURL(file);

        // Set the audio source
        if (audioPreview) {
            // Remove existing source elements
            while (audioPreview.firstChild) {
                audioPreview.removeChild(audioPreview.firstChild);
            }

            // Create and add new source element
            const source = document.createElement('source');
            source.src = audioUrl;
            source.type = file.type || 'audio/wav';
            audioPreview.appendChild(source);

            // Force reload of audio element
            audioPreview.load();

            // Show the preview section
            if (previewSection) {
                previewSection.style.display = 'block';
            }

            // Show save button if user is authenticated
            if (saveVoiceBtn) {
                const generateBtn = document.getElementById('generateBtn');
                const isAuthenticated = generateBtn && generateBtn.dataset.isAuthenticated === 'true';

                if (isAuthenticated) {
                    saveVoiceBtn.style.display = 'block';
                }
            }

            // Add event listener to check audio duration once metadata is loaded
            audioPreview.onloadedmetadata = function() {
                const duration = audioPreview.duration;
                // No need to revoke here
                if (duration < 3 || duration > 15) {
                    // Show warning if duration is not in the acceptable range
                    alert(`Audio length should be between 3 and 15 seconds. Current length is ${duration.toFixed(1)} seconds.`);
                }
            };
             audioPreview.onerror = function() {
                 URL.revokeObjectURL(audioUrl);
                 alert('Error loading audio preview.');
                 previewSection.style.display = 'none';
                 if(saveVoiceBtn) saveVoiceBtn.style.display = 'none';
            };
        }
    } else {
        // Hide preview if no file is selected
        if (previewSection) {
            previewSection.style.display = 'none';
        }

        // Hide save button
        if (saveVoiceBtn) {
            saveVoiceBtn.style.display = 'none';
        }
    }
}

// Add event listeners for all audio file inputs
document.addEventListener('DOMContentLoaded', function() {
    const audioFileInput = document.getElementById('audioFile');
    if (audioFileInput) {
        audioFileInput.addEventListener('change', handleAudioFileChange);
    }

    const longTextAudioFileInput = document.getElementById('longTextAudioFile');
    if (longTextAudioFileInput) {
        longTextAudioFileInput.addEventListener('change', handleLongTextAudioFileChange);
    }

    // Add event listener for the long text save voice button
    const longTextSaveVoiceBtn = document.getElementById('longTextSaveVoiceBtn');
    if (longTextSaveVoiceBtn) {
        longTextSaveVoiceBtn.addEventListener('click', function() {
            const audioFile = document.getElementById('longTextAudioFile').files[0];
            const transcription = document.getElementById('longTextTranscription').value;

            if (!audioFile) {
                alert('Please upload an audio file first.');
                return;
            }

            if (!transcription || transcription.trim() === '') {
                alert('Please enter the text corresponding to the audio.');
                return;
            }

            // Use the transcription as the voice name instead of asking the user
            const voiceName = transcription.length > 20
                ? transcription.substring(0, 17) + '...'
                : transcription;

            // Disable button and show loading state
            longTextSaveVoiceBtn.disabled = true;
            const originalText = longTextSaveVoiceBtn.innerHTML;
            longTextSaveVoiceBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Saving...';

            // Create form data
            const formData = new FormData();
            formData.append('audio_file', audioFile);
            formData.append('transcription', transcription);
            formData.append('voice_name', voiceName);

            // Submit using fetch API
            fetch('/save_voice_reference', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                     return response.json().then(errData => {
                         throw new Error(errData.message || `Server responded with status: ${response.status}`);
                    }).catch(() => {
                         throw new Error(`Server responded with status: ${response.status}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                // Reset button
                longTextSaveVoiceBtn.disabled = false;
                longTextSaveVoiceBtn.innerHTML = originalText;

                if (data.success) {
                    // Show success message
                    alert('Voice saved successfully! You can use it after refreshing.');

                    // Update the saved voices dropdown if it exists
                    const savedVoicesSelect = document.getElementById('longTextSavedVoicesSelect');
                    if (savedVoicesSelect) {
                        try {
                            // Call the existing function to refresh saved voices
                            refreshSavedVoicesOnly().then(latestVoiceId => {
                                // Select the latest voice if available
                                if (latestVoiceId) {
                                    savedVoicesSelect.value = latestVoiceId;

                                    // Trigger change event to update UI
                                    const event = new Event('change', { bubbles: true });
                                    savedVoicesSelect.dispatchEvent(event);
                                }
                            }).catch(err => {
                                console.error('Error updating saved voices list:', err);
                            });
                        } catch (updateError) {
                            console.error('Error updating saved voices UI:', updateError);
                            // We still show success because the voice was saved
                        }
                    }
                } else {
                    // Show error message
                    alert(data.message || 'Failed to save voice. Please try again later.');
                }
            })
            .catch(error => {
                console.error('Error saving voice:', error);
                longTextSaveVoiceBtn.disabled = false;
                longTextSaveVoiceBtn.innerHTML = originalText;
                alert(error.message || 'An error occurred while saving the voice. Please try again later.');
            });
        });
    }

    // Add event listeners for the long text refresh and manage buttons
    const longTextRefreshVoicesBtn = document.getElementById('longTextRefreshVoicesBtn');
    if (longTextRefreshVoicesBtn) {
        longTextRefreshVoicesBtn.addEventListener('click', function() {
            // Re-use the main refresh logic by triggering its button click
            const mainRefreshBtn = document.getElementById('refreshVoicesBtn');
            if (mainRefreshBtn) mainRefreshBtn.click();
             // Also refresh voices in the long text dropdown explicitly
            refreshSavedVoices('longTextSavedVoicesSelect');
        });
    }

    const longTextManageVoicesBtn = document.getElementById('longTextManageVoicesBtn');
    if (longTextManageVoicesBtn) {
        longTextManageVoicesBtn.addEventListener('click', function() {
             // Re-use the main manage logic by triggering its button click
            const mainManageBtn = document.getElementById('manageVoicesBtn');
            if (mainManageBtn) mainManageBtn.click();
        });
    }


    // Add event listener for saved voices select in long text tab
    const longTextSavedVoicesSelect = document.getElementById('longTextSavedVoicesSelect');
    if (longTextSavedVoicesSelect) {
        longTextSavedVoicesSelect.addEventListener('change', function() {
            const selectedOption = this.options[this.selectedIndex];
            if (!selectedOption.value) return;

            const audioUrl = selectedOption.dataset.audioUrl;
            const transcription = selectedOption.dataset.transcription;

            if (audioUrl && transcription) {
                 // Set the transcription text
                const longTextTranscriptionInput = document.getElementById('longTextTranscription');
                if(longTextTranscriptionInput) longTextTranscriptionInput.value = transcription;

                // Fetch the audio file and simulate a file upload
                fetch(audioUrl)
                    .then(response => {
                         if (!response.ok) throw new Error('Failed to fetch audio file');
                         return response.blob();
                     })
                    .then(blob => {
                        // Create a File object from the blob
                         const urlParts = audioUrl.split('/');
                         const filename = urlParts[urlParts.length - 1] || 'saved_voice.wav';
                         const file = new File([blob], filename, { type: blob.type || "audio/wav" });

                        // Create a new FileList containing this file
                        const longTextAudioFile = document.getElementById('longTextAudioFile');

                        // Trigger a file selection event programmatically
                        const dataTransfer = new DataTransfer();
                        dataTransfer.items.add(file);
                        longTextAudioFile.files = dataTransfer.files;

                        // Trigger change event
                        const event = new Event('change', { bubbles: true });
                        longTextAudioFile.dispatchEvent(event);
                    })
                    .catch(error => {
                        console.error('Error loading saved voice:', error);
                        alert('Error loading saved voice. Please try again later.'); // Translated
                    });
            }
        });
    }

});


// Function to fetch saved voices - refined
function fetchSavedVoices() {
    return fetch('/get_saved_voices', {
        method: 'GET',
        headers: {
            'Cache-Control': 'no-cache, no-store, must-revalidate'
        }
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`Server responded with status: ${response.status}`);
        }
        return response.json();
    });
}

// Function to populate speaker dropdowns - refined
function loadSavedVoicesForSpeakers() {
    console.log("Loading saved voices for speakers...");

    // Ensure convertToChinaTime function exists
    if (typeof convertToChinaTime !== 'function') {
        console.log("convertToChinaTime function not found, creating it...");
        window.convertToChinaTime = function(utcTimeStr) {
             try {
                 const utcDate = new Date(utcTimeStr);
                 const options = {
                    year: 'numeric', month: '2-digit', day: '2-digit',
                    hour: '2-digit', minute: '2-digit', hour12: false
                 };
                 const localDate = new Date(utcDate.getTime() + (8 * 60 * 60 * 1000)); // Adjust for timezone if needed
                 return localDate.toLocaleString('en-CA', options).replace(', ', ' ');
             } catch (e) { console.error('Error converting time:', e); return utcTimeStr; }
        };
    }

    // Show loading indicator
    document.querySelectorAll('.speaker-voice-select').forEach(select => {
        select.innerHTML = '<option value="">Loading...</option>'; // Translated
        select.disabled = true;
    });

    fetchSavedVoices()
        .then(data => {
            const speakerSelects = document.querySelectorAll('.speaker-voice-select');
            if (data.success && data.voices && data.voices.length > 0) {
                speakerSelects.forEach(select => {
                    select.innerHTML = '';
                    select.disabled = false;
                    const defaultOption = document.createElement('option');
                    defaultOption.value = '';
                    defaultOption.textContent = '-- Select Voice --'; // Translated
                    defaultOption.selected = true;
                    select.appendChild(defaultOption);

                    data.voices.forEach(voice => {
                        const option = document.createElement('option');
                        option.value = voice.id;
                        option.dataset.audioUrl = voice.audio_url;
                        option.dataset.transcription = voice.transcription;
                        const transcriptionPreview = voice.transcription.length > 20
                            ? voice.transcription.substring(0, 17) + '...'
                            : voice.transcription;
                        const chinaTime = convertToChinaTime(voice.created_at);
                        option.textContent = `${transcriptionPreview} (${chinaTime})`;
                        select.appendChild(option);
                    });
                    select.removeEventListener('change', handleSpeakerVoiceSelection); // Remove old listener
                    select.addEventListener('change', handleSpeakerVoiceSelection); // Add new listener
                });
                console.log(`Successfully loaded ${data.voices.length} voices for speaker selects`);
            } else {
                const noVoicesMessage = `<option value="" selected disabled>No saved voices found. Please save a voice in the 'Default Model' tab first.</option>`; // Translated
                speakerSelects.forEach(select => {
                    select.innerHTML = noVoicesMessage;
                    select.disabled = true;
                });
                if (!data.success) console.error('Server reported error:', data.error || 'Unknown error');
                else console.log("No saved voices found");
            }
        })
        .catch(error => {
            console.error('Error loading saved voices for speakers:', error);
             const loginMessage = `<option value="" selected disabled>Please log in to your DreamSpeech account first.</option>`; // Translated
            document.querySelectorAll('.speaker-voice-select').forEach(select => {
                select.innerHTML = loginMessage;
                select.disabled = true;
            });
        });
}

// Function to refresh the saved voices for speakers
function refreshSavedVoicesForSpeakers() {
    loadSavedVoicesForSpeakers();
}

// Function to handle multi-speaker submission - refined
async function handleMultiSpeakerSubmission(e) {
    if (e && e.preventDefault) e.preventDefault();

    const multiSpeakerGenerateBtn = document.getElementById('multiSpeakerGenerateBtn');
    const loadingSpinner = document.getElementById('loadingSpinner');
    const audioContainer = document.getElementById('audioContainer');
    const speakerSections = document.querySelectorAll('.speaker-section');
    const multiSpeakerSpeedSlider = document.getElementById('multiSpeakerSpeedSlider');
    const speed = multiSpeakerSpeedSlider ? parseFloat(multiSpeakerSpeedSlider.value) : 1.0;

    // Validate inputs
    const validation = validateMultiSpeakerInputs();
    if (!validation.isValid) {
        alert('Please select a voice and enter text for at least one speaker.'); // Translated
        return;
    }
    if (!validation.isTextLengthValid) {
        alert(`In Multi-Speaker mode, the total text length cannot exceed ${validation.maxLength} characters. Current length: ${validation.totalTextLength} characters.`); // Translated
        return;
    }

    // Disable button
    if (multiSpeakerGenerateBtn) {
        multiSpeakerGenerateBtn.disabled = true;
        multiSpeakerGenerateBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Generating...'; // Translated
    }

    // Get speaker data
    const speakerData = [];
    let totalTextForSensitiveCheck = '';
    for (const section of speakerSections) {
         if (section.style.display === 'none') continue; // Skip hidden sections
        const select = section.querySelector('.speaker-voice-select');
        const textarea = section.querySelector('.speaker-text');
        if (select.value && textarea.value.trim()) {
            const selectedOption = select.options[select.selectedIndex];
            const text = textarea.value.trim();
            speakerData.push({
                voiceId: select.value,
                audioUrl: selectedOption.dataset.audioUrl,
                transcription: selectedOption.dataset.transcription,
                text: text
            });
            totalTextForSensitiveCheck += text + ' '; // Concatenate for check
        }
    }

     // Check for sensitive words
    const foundSensitiveWords = checkSensitiveWords(totalTextForSensitiveCheck);
    if (foundSensitiveWords.length > 0) {
        document.getElementById('sensitiveWordsList').textContent = foundSensitiveWords.join(', ');
        sensitiveWordModal.show();
        if (multiSpeakerGenerateBtn) {
            multiSpeakerGenerateBtn.disabled = false;
            multiSpeakerGenerateBtn.innerHTML = '<i class="fas fa-magic me-2"></i>Generate Multi-Speaker Audio'; // Reset button text
        }
        return;
    }


    // Show loading state
    if (loadingSpinner) loadingSpinner.style.display = 'block';
    if (audioContainer) audioContainer.style.display = 'none';
    document.getElementById('errorAlert').style.display = 'none';

    try {
        const formData = new FormData();
        formData.append('is_multi_speaker', 'true');
        formData.append('speaker_count', speakerData.length.toString());
        formData.append('speed', speed.toString());

        // Add each speaker's data (fetch audio blob)
        for (let i = 0; i < speakerData.length; i++) {
            const speaker = speakerData[i];
            const audioResponse = await fetch(speaker.audioUrl);
            if (!audioResponse.ok) throw new Error(`Could not fetch audio file for Speaker ${i+1}. Please check your network connection.`); // Translated
            const audioBlob = await audioResponse.blob();
            const urlParts = speaker.audioUrl.split('/');
            const filename = urlParts[urlParts.length - 1] || `speaker_${i+1}_voice.wav`;
            const audioFile = new File([audioBlob], filename, { type: audioBlob.type || 'audio/wav' });
            formData.append(`audio_file_${i}`, audioFile);
            formData.append(`transcription_${i}`, speaker.transcription);
            formData.append(`text_${i}`, speaker.text);
        }

        console.log("Submitting multi-speaker TTS request...");
        const response = await fetch('/multi_speaker_tts', {
            method: 'POST',
            body: formData
        });

        if (!response.ok) {
            let errorMessage = 'Failed to generate audio. Please try again later.'; // Translated
            try {
                const errorData = await response.json();
                if (errorData && errorData.error) errorMessage = errorData.error;
            } catch (parseError) { console.error("Error parsing error response:", parseError); }
            throw new Error(errorMessage);
        }

        const data = await response.json();
        if (!data || !data.url) throw new Error(data.error || 'Server returned an invalid audio URL. Please try again later.'); // Translated

        console.log("Audio URL received:", data.url);
        finishAudioGeneration(data.url);
    } catch (error) {
        console.error("Error in multi-speaker TTS:", error);
        showError(error.message || 'Failed to generate audio. Please try again later.'); // Translated
        if (loadingSpinner) loadingSpinner.style.display = 'none';
    } finally {
        // Always re-enable button
        if (multiSpeakerGenerateBtn) {
            multiSpeakerGenerateBtn.disabled = false;
            multiSpeakerGenerateBtn.innerHTML = '<i class="fas fa-magic me-2"></i>Generate Multi-Speaker Audio'; // Reset text
        }
    }
}

// Function to handle voice selection change for a speaker
function handleSpeakerVoiceSelection(event) {
    const select = event.target;
    const selectedOption = select.options[select.selectedIndex];
    const speakerSection = select.closest('.speaker-section');

    // Remove previous indicator if exists
    const existingIndicator = speakerSection.querySelector('.voice-selected-indicator');
    if (existingIndicator) existingIndicator.remove();

    // Reset validation style
     select.classList.remove('is-invalid');
     select.style.borderColor = '';
     select.style.boxShadow = '';

    if (selectedOption && selectedOption.value) {
        console.log(`Selected voice ID: ${selectedOption.value} for speaker section`);

        // Add visual feedback
        select.style.borderColor = '#4ECDC4'; // Use a success color
        select.style.boxShadow = '0 0 0 0.2rem rgba(78, 205, 196, 0.25)';

        // Add a check icon
        const indicator = document.createElement('span'); // Use span for inline display
        indicator.className = 'voice-selected-indicator text-success ms-2';
        indicator.innerHTML = '<i class="fas fa-check-circle"></i>';
        indicator.style.fontSize = '0.9rem';
        // Insert after the select element within the flex container
        select.parentNode.insertBefore(indicator, select.nextSibling);

        // Optional: Focus the textarea
        const textarea = speakerSection.querySelector('.speaker-text');
        if (textarea) textarea.focus();
    }
}


// Function to validate multi-speaker inputs and highlight issues
function validateMultiSpeakerInputs() {
    const speakerSections = document.querySelectorAll('.speaker-section');
    let isValid = false;
    let totalTextLength = 0;
    let validSpeakerCount = 0;

    // Reset validation styles
    speakerSections.forEach(section => {
        const select = section.querySelector('.speaker-voice-select');
        const textarea = section.querySelector('.speaker-text');
        if (select) select.classList.remove('is-invalid');
        if (textarea) textarea.classList.remove('is-invalid');
    });

    // Iterate over visible sections only
    for (const section of speakerSections) {
        if (section.style.display === 'none') continue; // Skip hidden

        const select = section.querySelector('.speaker-voice-select');
        const textarea = section.querySelector('.speaker-text');
        const hasVoice = select && select.value !== '';
        const hasText = textarea && textarea.value.trim() !== '';

        // A speaker needs both voice and text
        if (hasVoice && hasText) {
            validSpeakerCount++;
            totalTextLength += textarea.value.trim().length;
        } else if (hasVoice && !hasText) {
            // Voice selected but no text
            if (textarea) textarea.classList.add('is-invalid');
        } else if (!hasVoice && hasText) {
            // Text entered but no voice
            if (select) select.classList.add('is-invalid');
        }
    }

    // At least one valid speaker required
    isValid = validSpeakerCount > 0;

    // Check total length
    const hasMembership = window.hasMembership || false;
    const maxLength = hasMembership ? 1000 : 200;
    const isTextLengthValid = totalTextLength <= maxLength;

    // If total length exceeds limit, mark all textareas as potentially invalid (or show a general error)
    if (!isTextLengthValid && isValid) {
         // Mark textareas of valid speakers as potentially causing the issue
         for (const section of speakerSections) {
             if (section.style.display === 'none') continue;
             const select = section.querySelector('.speaker-voice-select');
             const textarea = section.querySelector('.speaker-text');
             if (select && select.value !== '' && textarea && textarea.value.trim() !== '') {
                 textarea.classList.add('is-invalid'); // Indicate length issue
             }
         }
         // Optionally set isValid to false if length is the primary validation failure
         // isValid = false;
    }


    return {
        isValid,
        validSpeakerCount,
        totalTextLength,
        isTextLengthValid,
        maxLength
    };
}

// Function to update speaker section visibility based on membership
function updateMultiSpeakerVisibility() {
     const hasMembership = window.hasMembership || false;
     const speakerSections = [
         document.getElementById('speaker-section-3'),
         document.getElementById('speaker-section-4'),
         document.getElementById('speaker-section-5'),
         document.getElementById('speaker-section-6')
     ];
     const addSpeakerBtnContainer = document.getElementById('addSpeakerBtnContainer');
     let visibleCount = 2; // Start with 2 default speakers

     // Count currently visible optional speakers
     speakerSections.forEach(section => {
         if (section && section.style.display === 'block') {
             visibleCount++;
         }
     });

     if (hasMembership) {
         // Members can see up to 6 speakers
         if (addSpeakerBtnContainer) {
             addSpeakerBtnContainer.style.display = visibleCount < 6 ? 'block' : 'none';
         }
     } else {
         // Non-members limited to 2 speakers
         speakerSections.forEach(section => {
             if (section) section.style.display = 'none';
         });
         if (addSpeakerBtnContainer) addSpeakerBtnContainer.style.display = 'none';
         visibleCount = 2; // Reset count for non-members
     }

     // Update the info text
     const multiSpeakerLimitsText = document.getElementById('multiSpeakerLimitsText');
     if (multiSpeakerLimitsText) {
         multiSpeakerLimitsText.textContent = hasMembership
             ? 'Members support 6 speakers / 1000 characters.'
             : 'Free users support 2 speakers / 200 characters. Members support 6 speakers / 1000 characters.';
     }

     return visibleCount; // Return the current visible count
}


// Function to initialize multi-speaker features
function initializeMultiSpeakerFeatures() {
     const addSpeakerBtn = document.getElementById('addSpeakerBtn');
     const addSpeakerBtnContainer = document.getElementById('addSpeakerBtnContainer');
     const speakerSections = [
         null, // Placeholder for speaker 1
         null, // Placeholder for speaker 2
         document.getElementById('speaker-section-3'),
         document.getElementById('speaker-section-4'),
         document.getElementById('speaker-section-5'),
         document.getElementById('speaker-section-6')
     ];
     let visibleSpeakers = 2; // Track visible speakers

     // Update visibility on load
     visibleSpeakers = updateMultiSpeakerVisibility();

     // Add Speaker Button Logic
     if (addSpeakerBtn && addSpeakerBtnContainer) {
         addSpeakerBtn.addEventListener('click', function() {
             if (!window.hasMembership) return; // Only members can add

             if (visibleSpeakers < 6) {
                 const nextSpeakerSection = speakerSections[visibleSpeakers];
                 if (nextSpeakerSection) {
                     nextSpeakerSection.style.display = 'block';
                     // Load voices if needed
                     const select = nextSpeakerSection.querySelector('.speaker-voice-select');
                     if (select && select.options.length <= 1) {
                         loadSavedVoicesForSpeakers();
                     }
                     visibleSpeakers++;
                     // Hide button if max reached
                     if (visibleSpeakers === 6) {
                         addSpeakerBtnContainer.style.display = 'none';
                     }
                 }
             }
         });
     }

     // Refresh Button Logic
     const refreshMultiSpeakerVoicesBtn = document.getElementById('refreshMultiSpeakerVoicesBtn');
     if (refreshMultiSpeakerVoicesBtn) {
         refreshMultiSpeakerVoicesBtn.addEventListener('click', function() {
             this.disabled = true;
             const originalHTML = this.innerHTML;
             this.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Loading...'; // Translated
             loadSavedVoicesForSpeakers();
             setTimeout(() => {
                 this.disabled = false;
                 this.innerHTML = originalHTML;
             }, 1500);
         });
     }

     // Generate Button Logic
     const multiSpeakerGenerateBtn = document.getElementById('multiSpeakerGenerateBtn');
     if (multiSpeakerGenerateBtn) {
         multiSpeakerGenerateBtn.addEventListener('click', function() {
             handleMultiSpeakerSubmission(new Event('submit')); // Simulate form submission
         });
     }

      // Listen for membership changes
      document.addEventListener('membershipStatusChanged', function() {
          visibleSpeakers = updateMultiSpeakerVisibility(); // Update visibility on status change
      });
}

// Function to reset the user's points if it's a new day
function resetPointsIfNewDay() {
    fetch('/get_remaining_points', {
        method: 'GET',
        headers: {
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache',
            'Expires': '0'
        },
        credentials: 'same-origin'
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            console.log("Points reset check completed. Current points:", data.points);

            // If there's a points display in the navbar, update it
            if (typeof updatePointsDisplay === 'function') {
                updatePointsDisplay();
            }
        } else {
            console.error("Error checking/resetting points:", data.message);
        }
    })
    .catch(error => {
        console.error("Error in resetPointsIfNewDay:", error);
    });
}

// Display filename when a file is selected
function initFileDisplayNames() {
    const audioFileInput = document.getElementById('audioFile');
    if (audioFileInput) {
        audioFileInput.addEventListener('change', function() {
            if (this.files.length > 0) {
                // Add a class to indicate file was selected and use data attribute to store filename
                this.classList.add('has-file');
                this.setAttribute('data-filename', this.files[0].name);
            } else {
                // Remove the class and data attribute if no file selected
                this.classList.remove('has-file');
                this.removeAttribute('data-filename');
            }
        });
    }

    const longTextAudioFileInput = document.getElementById('longTextAudioFile');
    if (longTextAudioFileInput) {
        longTextAudioFileInput.addEventListener('change', function() {
            if (this.files.length > 0) {
                // Add a class to indicate file was selected and use data attribute to store filename
                this.classList.add('has-file');
                this.setAttribute('data-filename', this.files[0].name);
            } else {
                // Remove the class and data attribute if no file selected
                this.classList.remove('has-file');
                this.removeAttribute('data-filename');
            }
        });
    }
}

// ... existing code ...
</script>
{% endblock %}
